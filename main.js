/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/@obsidian-ai-providers/sdk/dist/index.js
var require_dist = __commonJS({
  "node_modules/@obsidian-ai-providers/sdk/dist/index.js"(exports, module2) {
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var sdk_exports = {};
    __export2(sdk_exports, {
      initAI: () => initAI2,
      waitForAI: () => waitForAI3
    });
    module2.exports = __toCommonJS2(sdk_exports);
    var import_obsidian4 = require("obsidian");
    var FALLBACK_TIMEOUT = 100;
    var REQUIRED_AI_PROVIDERS_VERSION = 1;
    var AI_PROVIDERS_READY_EVENT = "ai-providers-ready";
    var aiProvidersReadyAiResolver = null;
    async function waitForAIProviders(app, plugin) {
      if (aiProvidersReadyAiResolver) {
        return aiProvidersReadyAiResolver;
      }
      const abortController = new AbortController();
      let aiProvidersReady = /* @__PURE__ */ __name(() => {
      }, "aiProvidersReady");
      const result = {
        promise: new Promise((resolve, reject) => {
          aiProvidersReady = /* @__PURE__ */ __name(() => {
            app.workspace.off(AI_PROVIDERS_READY_EVENT, aiProvidersReady);
            aiProvidersReadyAiResolver = null;
            resolve(app.aiProviders);
          }, "aiProvidersReady");
          if (app.aiProviders) {
            aiProvidersReady();
          } else {
            const eventRef = app.workspace.on(AI_PROVIDERS_READY_EVENT, aiProvidersReady);
            plugin.registerEvent(eventRef);
          }
          abortController.signal.addEventListener("abort", () => {
            app.workspace.off(AI_PROVIDERS_READY_EVENT, aiProvidersReady);
            aiProvidersReadyAiResolver = null;
            reject(new Error("Waiting for AI Providers was cancelled"));
          });
        }),
        cancel: () => abortController.abort()
      };
      if (!app.aiProviders) {
        aiProvidersReadyAiResolver = result;
      }
      return result;
    }
    __name(waitForAIProviders, "waitForAIProviders");
    var _AIProvidersManager = class {
      constructor(app, plugin) {
        this.app = app;
        this.plugin = plugin;
      }
      static getInstance(app, plugin) {
        if (!this.instance) {
          if (!app || !plugin) {
            throw new Error("AIProvidersManager not initialized. Call initialize() first");
          }
          this.instance = new _AIProvidersManager(app, plugin);
        }
        return this.instance;
      }
      static reset() {
        this.instance = null;
      }
      getApp() {
        return this.app;
      }
      getPlugin() {
        return this.plugin;
      }
    };
    var AIProvidersManager = _AIProvidersManager;
    __name(AIProvidersManager, "AIProvidersManager");
    AIProvidersManager.instance = null;
    async function initAI2(app, plugin, onDone) {
      AIProvidersManager.getInstance(app, plugin);
      let isFallbackShown = false;
      try {
        const timeout = setTimeout(async () => {
          plugin.addSettingTab(new AIProvidersFallbackSettingsTab(app, plugin));
          isFallbackShown = true;
        }, FALLBACK_TIMEOUT);
        const aiProvidersAiResolver = await waitForAIProviders(app, plugin);
        const aiProviders = await aiProvidersAiResolver.promise;
        clearTimeout(timeout);
        try {
          aiProviders.checkCompatibility(REQUIRED_AI_PROVIDERS_VERSION);
        } catch (error) {
          console.error(`AI Providers compatibility check failed: ${error}`);
          if (error.code === "version_mismatch") {
            plugin.addSettingTab(new AIProvidersFallbackSettingsTab(app, plugin));
            throw new Error(`AI Providers version ${REQUIRED_AI_PROVIDERS_VERSION} is required`);
          }
          throw error;
        }
        await onDone();
      } finally {
        if (isFallbackShown && app.plugins) {
          await app.plugins.disablePlugin(plugin.manifest.id);
          await app.plugins.enablePlugin(plugin.manifest.id);
        }
      }
    }
    __name(initAI2, "initAI");
    async function waitForAI3() {
      const manager = AIProvidersManager.getInstance();
      return waitForAIProviders(manager.getApp(), manager.getPlugin());
    }
    __name(waitForAI3, "waitForAI");
    var AIProvidersFallbackSettingsTab = class extends import_obsidian4.PluginSettingTab {
      constructor(app, plugin) {
        super(app, plugin);
        this.plugin = plugin;
      }
      async display() {
        const { containerEl } = this;
        containerEl.empty();
        const aiProvidersNotice = containerEl.createEl("div", {
          cls: "ai-providers-notice"
        });
        aiProvidersNotice.appendChild((0, import_obsidian4.sanitizeHTMLToDom)(`
            <p>\u26A0\uFE0F This plugin requires <a href="obsidian://show-plugin?id=ai-providers">AI Providers</a> plugin to be installed.</p>
            <p>Please install and configure AI Providers plugin first.</p>
        `));
      }
    };
    __name(AIProvidersFallbackSettingsTab, "AIProvidersFallbackSettingsTab");
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => LocalGPT
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");
var import_sdk2 = __toESM(require_dist());

// node_modules/uuid/dist/esm-browser/stringify.js
var byteToHex = [];
for (i = 0; i < 256; ++i) {
  byteToHex.push((i + 256).toString(16).slice(1));
}
var i;
function unsafeStringify(arr, offset = 0) {
  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
}

// node_modules/uuid/dist/esm-browser/rng.js
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}

// node_modules/uuid/dist/esm-browser/native.js
var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var native_default = {
  randomUUID
};

// node_modules/uuid/dist/esm-browser/v4.js
function v4(options, buf, offset) {
  if (native_default.randomUUID && !buf && !options) {
    return native_default.randomUUID();
  }
  options = options || {};
  var rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (var i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
var v4_default = v4;

// src/LocalGPTSettingTab.ts
var import_obsidian = require("obsidian");
var import_sdk = __toESM(require_dist());

// src/defaultSettings.ts
var defaultGroupId = v4_default();
var defaultActionIds = Array.from({ length: 6 }, () => v4_default());
var DEFAULT_ACTIONS = [
  {
    id: defaultActionIds[0],
    groupId: defaultGroupId,
    name: "\u{1FA84} General help",
    prompt: "",
    system: "You are an assistant helping a user write more content in a document based on a prompt. Output in markdown format. Do not use links. Do not include literal content from the original document.",
    replace: false,
    providerId: null,
    temperature: null
    // Use global default
  },
  {
    id: defaultActionIds[1],
    groupId: defaultGroupId,
    name: "\u270D\uFE0F Continue writing",
    prompt: "Act as a professional editor with many years of experience as a writer. Carefully finalize the following text, add details, use facts and make sure that the meaning and original style are preserved. Purposely write in detail, with examples, so that your reader is comfortable, even if they don't understand the specifics. Don't use clericalisms, evaluations without proof with facts, passive voice. Use Markdown markup language for formatting. Answer only content and nothing else, no introductory words, only substance.",
    system: "You are an AI assistant that follows instruction extremely well. Help as much as you can.",
    replace: false,
    providerId: null,
    temperature: null
    // Use global default
  },
  {
    id: defaultActionIds[2],
    groupId: defaultGroupId,
    name: "\u{1F36D} Summarize",
    prompt: "Make a concise summary of the key points of the following text.",
    system: "You are an AI assistant that follows instruction extremely well. Help as much as you can.",
    replace: false,
    providerId: null,
    temperature: null
    // Use global default
  },
  {
    id: defaultActionIds[3],
    groupId: defaultGroupId,
    name: "\u{1F4D6} Fix spelling and grammar",
    prompt: "Proofread the below for spelling and grammar.",
    system: "You are an AI assistant that follows instruction extremely well. Help as much as you can.",
    replace: true,
    providerId: null,
    temperature: null
    // Use global default
  },
  {
    id: defaultActionIds[4],
    groupId: defaultGroupId,
    name: "\u2705 Find action items",
    prompt: 'Act as an assistant helping find action items inside a document. An action item is an extracted task or to-do found inside of an unstructured document. Use Markdown checkbox format: each line starts with "- [ ] "',
    system: "You are an AI assistant that follows instruction extremely well. Help as much as you can.",
    replace: false,
    providerId: null,
    temperature: null
    // Use global default
  },
  {
    id: defaultActionIds[5],
    groupId: defaultGroupId,
    name: "\u{1F9E0} New System Prompt",
    prompt: "",
    system: `You are a highly skilled AI prompt engineer with expertise in creating tailored prompts for a wide range of professional roles. You have a deep knowledge of how to craft prompts that effectively guide the language model to produce high-quality, contextually appropriate responses.

Your task is to generate a custom system prompt for different roles based on user input. This involves understanding the specific requirements of each role, the context in which the prompt will be used, and the desired output format. You are skilled in structuring prompts that ensure clarity, relevance, and utility.

Create a custom system prompt for an LLM to assist users in generating contextually appropriate and highly effective responses for various roles. The prompt should provide clear instructions to the LLM on how to handle specific scenarios related to the role, including the tone and format of the response.

Start by providing a role "You are..." and context as a summary of the situation or background information relevant to the prompt. Define the main objective, outlining what the LLM needs to accomplish.

Include instructions on the appropriate style and tone (e.g., formal, casual, technical, empathetic) based on the role and audience. Identify the target audience to tailor the LLM's output effectively. Specify the format of the response, whether it should be a narrative, bullet points, step-by-step guide, code, or another format. Avoid using headings or examples; the prompt should read as a continuous, cohesive set of instructions.
ANSWER PROMPT AND NOTHING ELSE!`,
    replace: false,
    providerId: null,
    temperature: null
    // Use global default
  }
];
var DEFAULT_ACTION_GROUPS = [
  {
    id: defaultGroupId,
    name: "General",
    actions: DEFAULT_ACTIONS
  }
];
var DEFAULT_SETTINGS = {
  _version: 8,
  // Current settings version
  aiProviders: {
    main: null,
    embedding: null,
    vision: null
  },
  defaults: {
    creativity: "balanced"
    // Default creativity level key
  },
  actionGroups: DEFAULT_ACTION_GROUPS,
  showProviderInContextMenu: false,
  showCreativityInContextMenu: false,
  // <<< ADDED: Default to false
  currentGroupId: defaultGroupId
  // Default to the ID of the first group
};
var CREATIVITY = {
  "focused": { temperature: 0.2 },
  "creative": { temperature: 0.5 },
  "balanced": { temperature: 1 },
  // Matches default key above
  "explorer": { temperature: 1.5 },
  "max": { temperature: 2 }
};
var SELECTION_KEYWORD = "{{selection}}";
var CONTEXT_KEYWORD = "{{context}}";
var CONTEXT_CONDITION_START = "{{=CONTEXT_START=}}";
var CONTEXT_CONDITION_END = "{{=CONTEXT_END=}}";

// src/logger.ts
var isNodeEnvironment = typeof process !== "undefined" && process.env;
var LogLevel = /* @__PURE__ */ ((LogLevel2) => {
  LogLevel2[LogLevel2["DEBUG"] = 0] = "DEBUG";
  LogLevel2[LogLevel2["INFO"] = 1] = "INFO";
  LogLevel2[LogLevel2["WARN"] = 2] = "WARN";
  LogLevel2[LogLevel2["ERROR"] = 3] = "ERROR";
  LogLevel2[LogLevel2["SUCCESS"] = 4] = "SUCCESS";
  return LogLevel2;
})(LogLevel || {});
var Logger = class {
  constructor() {
    this.logLevel = 0 /* DEBUG */;
    // Default to true if 'process' is unavailable (e.g., mobile), or check NODE_ENV
    this.isDevMode = isNodeEnvironment ? false : true;
    this.timers = /* @__PURE__ */ new Map();
    this.colorIndex = 0;
    // ESLint fix: removed : number
    this.colors = [
      "#FFB3BA",
      "#BAFFC9",
      "#BAE1FF",
      "#FFFFBA",
      "#FFDFBA",
      "#E0BBE4"
    ];
  }
  static getInstance() {
    if (!Logger.instance) {
      Logger.instance = new Logger();
    }
    return Logger.instance;
  }
  // Call this from your plugin's onload if you want to control log level via settings
  initialize(logLevel = 1 /* INFO */, isDev = this.isDevMode) {
    this.logLevel = logLevel;
    this.isDevMode = isDev;
    console.log(`[Logger] Initialized. Level: ${LogLevel[logLevel]}, DevMode: ${isDev}`);
  }
  setLogLevel(level) {
    this.logLevel = level;
  }
  logWithEmoji(level, message, ...args) {
    if (this.isDevMode && level >= this.logLevel) {
      const emoji = this.getEmojiForLevel(level);
      if (args.length === 0 || typeof args[0] !== "object") {
        console.log(`${emoji} %c${message}`, "font-weight: bold;", ...args);
      } else {
        console.groupCollapsed(`${emoji} %c${message}`, "font-weight: bold;");
        this.logArgs(args);
        console.groupEnd();
      }
    }
  }
  // Type args explicitly as unknown[]
  logArgs(args) {
    args.forEach((arg) => {
      console.log(arg);
    });
  }
  getEmojiForLevel(level) {
    switch (level) {
      case 0 /* DEBUG */:
        return "\u{1F41B}";
      case 1 /* INFO */:
        return "\u2139\uFE0F";
      case 2 /* WARN */:
        return "\u26A0\uFE0F";
      case 3 /* ERROR */:
        return "\u{1F6AB}";
      case 4 /* SUCCESS */:
        return "\u2705";
      default:
        return "";
    }
  }
  // Type args explicitly as unknown[]
  debug(message, ...args) {
    this.logWithEmoji(0 /* DEBUG */, message, ...args);
  }
  // Type args explicitly as unknown[]
  info(message, ...args) {
    this.logWithEmoji(1 /* INFO */, message, ...args);
  }
  // Type args explicitly as unknown[]
  warn(message, ...args) {
    this.logWithEmoji(2 /* WARN */, message, ...args);
  }
  // Type args explicitly as unknown[]
  error(message, ...args) {
    this.logWithEmoji(3 /* ERROR */, message, ...args);
  }
  // Type args explicitly as unknown[]
  success(message, ...args) {
    this.logWithEmoji(4 /* SUCCESS */, message, ...args);
  }
  // Type args explicitly as unknown[]
  table(message, ...args) {
    if (this.isDevMode && this.logLevel <= 0 /* DEBUG */) {
      console.groupCollapsed(`\u{1F4CA} %c${message}`, "font-weight: bold;");
      this.logNestedGroups(args);
      console.groupEnd();
    }
  }
  // Type args explicitly as unknown[]
  logNestedGroups(args) {
    args.forEach((arg) => {
      if (typeof arg === "object" && arg !== null) {
        this.logObjectAsGroups(arg);
      } else {
        console.log(arg);
      }
    });
  }
  // Type obj explicitly as Record<string, unknown>
  logObjectAsGroups(obj) {
    if (typeof Object.entries !== "function") {
      console.warn("[Logger] Object.entries not supported in this environment. Cannot log object details.");
      console.log(obj);
      return;
    }
    Object.entries(obj).forEach(([key, value]) => {
      if (typeof value === "object" && value !== null) {
        console.groupCollapsed(`${key}:`);
        this.logObjectAsGroups(value);
        console.groupEnd();
      } else {
        console.log(`${key}: ${value}`);
      }
    });
  }
  time(label) {
    if (this.isDevMode && this.logLevel <= 0 /* DEBUG */) {
      const color = this.getNextColor();
      this.timers.set(label, { startTime: performance.now(), color });
      console.log(
        `\u23F1\uFE0F %c${label}: timer started`,
        `color: black; font-weight: bold; background-color: ${color}; padding: 2px 5px; border-radius: 3px;`
      );
    }
  }
  timeEnd(label) {
    if (this.isDevMode && this.logLevel <= 0 /* DEBUG */) {
      const timerData = this.timers.get(label);
      if (timerData) {
        const duration = performance.now() - timerData.startTime;
        console.log(
          `\u23F1\uFE0F %c${label}: ${duration.toFixed(2)}ms`,
          `color: black; font-weight: bold; background-color: ${timerData.color}; padding: 2px 5px; border-radius: 3px;`
        );
        this.timers.delete(label);
      } else {
        console.warn(`Timer '${label}' does not exist`);
      }
    }
  }
  getNextColor() {
    const color = this.colors[this.colorIndex];
    this.colorIndex = (this.colorIndex + 1) % this.colors.length;
    return color;
  }
  separator(message = "") {
    if (this.isDevMode) {
      const lineLength = 50;
      const line = "\u2501".repeat(lineLength);
      if (message) {
        const paddedMessage = ` ${message} `;
        const remainingLength = lineLength - paddedMessage.length;
        const leftPadding = Math.max(0, Math.floor(remainingLength / 2));
        const rightPadding = Math.max(0, remainingLength - leftPadding);
        const separatorLine = line.slice(0, leftPadding) + paddedMessage + line.slice(0, rightPadding);
        console.log(`
%c${separatorLine}`, "color: #FF4500; font-weight: bold; font-size: 1.1em;");
      } else {
        console.log(`
%c${line}`, "color: #FF4500; font-weight: bold; font-size: 1.1em;");
      }
      console.log("");
    }
  }
};
var logger = Logger.getInstance();

// src/LocalGPTSettingTab.ts
var QUICK_ADD_SEPARATOR = "\u2702\uFE0F";
var QUICK_ADD_MAPPING = { name: "Name: ", system: "System: ", prompt: "Prompt: ", replace: "Replace: ", providerId: "ProviderID: ", temperature: "Creativity: " };
var ConfirmModal = class extends import_obsidian.Modal {
  constructor(app, title, message, onConfirm, confirmButtonText = "Confirm", confirmButtonClass = "mod-warning") {
    super(app);
    this.title = title;
    this.message = message;
    this.onConfirm = onConfirm;
    this.confirmButtonText = confirmButtonText;
    this.confirmButtonClass = confirmButtonClass;
  }
  onOpen() {
    const { contentEl, title, message, confirmButtonText, confirmButtonClass } = this;
    contentEl.createEl("h2", { text: title });
    contentEl.createEl("p", { text: message });
    new import_obsidian.Setting(contentEl).addButton((btn) => btn.setButtonText("Cancel").onClick(() => this.close())).addButton((btn) => btn.setButtonText(confirmButtonText).setClass(confirmButtonClass).onClick(async () => {
      try {
        await this.onConfirm();
      } catch (e) {
        logger.error("Error during modal confirm:", e);
        new import_obsidian.Notice("Operation failed. Check console.");
      } finally {
        this.close();
      }
    }));
  }
  onClose() {
    this.contentEl.empty();
  }
};
var InputModal = class extends import_obsidian.Modal {
  constructor(app, title, initialValue = "", onSubmit) {
    super(app);
    this.title = title;
    this.initialValue = initialValue;
    this.onSubmit = onSubmit;
    this.result = initialValue;
  }
  onOpen() {
    const { contentEl, title } = this;
    contentEl.createEl("h2", { text: title });
    new import_obsidian.Setting(contentEl).setName("New name").addText((text) => {
      this.inputComponent = text;
      text.setValue(this.initialValue).onChange((value) => {
        this.result = value;
      });
      text.inputEl.addEventListener("keydown", (e) => {
        if (e.key === "Enter") {
          e.preventDefault();
          this.submit();
        }
      });
    });
    new import_obsidian.Setting(contentEl).addButton((btn) => btn.setButtonText("Cancel").onClick(() => this.close())).addButton((btn) => btn.setButtonText("Save").setCta().onClick(() => this.submit()));
    setTimeout(() => {
      var _a;
      return (_a = this.inputComponent) == null ? void 0 : _a.inputEl.focus();
    }, 50);
  }
  async submit() {
    try {
      await this.onSubmit(this.result.trim());
    } catch (e) {
      logger.error("Error during modal submit:", e);
      new import_obsidian.Notice("Operation failed. Check console.");
    } finally {
      this.close();
    }
  }
  onClose() {
    this.contentEl.empty();
  }
};
var LocalGPTSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    var _a, _b, _c;
    super(app, plugin);
    // Dropdown options caches
    this.availableProviders = [];
    this.providerOptions = {};
    this.providerOptionsWithDefault = {};
    this.creativityOptions = {};
    this.creativityOptionsWithDefault = {};
    this.groupOptions = {};
    this.plugin = plugin;
    this.debouncedSave = (0, import_obsidian.debounce)(this.plugin.saveSettings.bind(this.plugin), 500, true);
    this.plugin.state = (_a = this.plugin.state) != null ? _a : {};
    this.plugin.state.editingActionId = (_b = this.plugin.state.editingActionId) != null ? _b : null;
    this.plugin.state.reorderingGroupId = (_c = this.plugin.state.reorderingGroupId) != null ? _c : null;
  }
  // Prepare dropdown options
  prepareDropdownOptions() {
    this.providerOptions = this.availableProviders.reduce((acc, provider) => {
      acc[provider.id] = provider.name;
      return acc;
    }, { "": "--- Select Provider ---" });
    this.providerOptionsWithDefault = this.availableProviders.reduce((acc, provider) => {
      acc[provider.id] = provider.name;
      return acc;
    }, { "": "Default (Use Global Setting)" });
    this.creativityOptions = Object.entries(CREATIVITY).reduce((acc, [key, value]) => {
      acc[key] = `${key.charAt(0).toUpperCase() + key.slice(1)} (~${value.temperature.toFixed(1)})`;
      return acc;
    }, {});
    this.creativityOptionsWithDefault = Object.entries(CREATIVITY).reduce((acc, [key, value]) => {
      acc[key] = `${key.charAt(0).toUpperCase() + key.slice(1)} (~${value.temperature.toFixed(1)})`;
      return acc;
    }, { "": "Default (Use Global Setting)" });
    this.groupOptions = (this.plugin.settings.actionGroups || []).reduce((acc, group) => {
      if ((group == null ? void 0 : group.id) && group.name)
        acc[group.id] = group.name;
      return acc;
    }, {});
  }
  // Find action and group by ID
  findActionAndGroup(actionId) {
    if (!actionId || !this.plugin.settings.actionGroups) {
      return { group: void 0, action: void 0, groupIndex: -1, actionIndex: -1 };
    }
    for (let groupIndex = 0; groupIndex < this.plugin.settings.actionGroups.length; groupIndex++) {
      const group = this.plugin.settings.actionGroups[groupIndex];
      if (!(group == null ? void 0 : group.actions))
        continue;
      const actionIndex = group.actions.findIndex((a) => (a == null ? void 0 : a.id) === actionId);
      if (actionIndex > -1) {
        const action = group.actions[actionIndex];
        if (action) {
          return { group, action, groupIndex, actionIndex };
        }
      }
    }
    return { group: void 0, action: void 0, groupIndex: -1, actionIndex: -1 };
  }
  // Create the description fragment for an action item
  createActionDescriptionFragment(action) {
    const fragment = document.createDocumentFragment();
    const maxLen = 80;
    const addDescLine = (label, value, fullTitle) => {
      if (value && value.trim()) {
        const lineDiv = fragment.createDiv({ cls: "setting-item-description-line" });
        lineDiv.createEl("strong", { text: `${label}: ` });
        const truncatedValue = value.length > maxLen ? value.substring(0, maxLen - 3) + "..." : value;
        lineDiv.appendText(truncatedValue);
        if (fullTitle || value.length > maxLen) {
          lineDiv.title = fullTitle || value;
        }
      }
    };
    const tagContainer = fragment.createDiv({ cls: "setting-item-tags-container" });
    const addTag = (text) => {
      tagContainer.createSpan({ text, cls: "local-gpt-setting-tag" });
    };
    addDescLine("System", action.system);
    addDescLine("Prompt", action.prompt);
    const hasProviderOverride = !!action.providerId;
    const hasCreativityOverride = action.temperature != null && this.creativityOptions[action.temperature];
    const hasReplace = action.replace;
    if (hasProviderOverride && action.providerId !== null) {
      const providerName = this.providerOptions[action.providerId] || `ID: ${action.providerId}`;
      addTag(`Provider: ${providerName.substring(0, 30)}${providerName.length > 30 ? "..." : ""}`);
    }
    if (hasCreativityOverride && action.temperature !== null) {
      addTag(`Creativity: ${this.creativityOptions[action.temperature]}`);
    }
    if (hasReplace) {
      addTag("Mode: Replace");
    }
    if (tagContainer.hasChildNodes()) {
      if (fragment.querySelector(".setting-item-description-line")) {
        fragment.createDiv({ cls: "setting-item-description-spacer" });
      }
      fragment.appendChild(tagContainer);
    }
    return fragment;
  }
  // Copy action details to clipboard string
  copyActionToString(action) {
    const parts = [];
    for (const key in QUICK_ADD_MAPPING) {
      const typedKey = key;
      const prefix = QUICK_ADD_MAPPING[typedKey];
      const value = action[typedKey];
      if (prefix && value !== void 0 && value !== null && value !== "") {
        if (typedKey === "replace") {
          if (value === true)
            parts.push(`${prefix}true`);
        } else if (typedKey === "temperature") {
          if (typeof value === "string" && CREATIVITY[value])
            parts.push(`${prefix}${value}`);
        } else if (typeof value === "string" && value.trim()) {
          parts.push(`${prefix}${value}`);
        }
      }
    }
    const actionString = parts.join(` ${QUICK_ADD_SEPARATOR}
`);
    navigator.clipboard.writeText(actionString).then(() => new import_obsidian.Notice(`Copied action "${action.name}" to clipboard.`)).catch((err) => {
      logger.error("Failed to copy action string:", err);
      new import_obsidian.Notice("Error copying action.");
    });
  }
  // Handle the logic for Quick Add
  async handleQuickAdd(inputValue, textComponent) {
    var _a, _b, _c, _d, _e, _f;
    if (!inputValue)
      return;
    logger.debug("Handling Quick Add:", inputValue);
    const targetGroup = (_a = this.plugin.settings.actionGroups) == null ? void 0 : _a[0];
    if (!targetGroup) {
      new import_obsidian.Notice("Error: No action groups exist to add the action to.");
      return;
    }
    const newAction = { id: v4_default(), groupId: targetGroup.id, name: "", prompt: "", system: "", replace: false, providerId: null, temperature: null };
    const parts = inputValue.split(QUICK_ADD_SEPARATOR);
    let nameFound = false;
    for (const part of parts) {
      const trimmedPart = part.trim();
      let foundKey = false;
      for (const key in QUICK_ADD_MAPPING) {
        const typedKey = key;
        const prefix = QUICK_ADD_MAPPING[typedKey];
        if (prefix && trimmedPart.startsWith(prefix)) {
          const value = trimmedPart.substring(prefix.length).trim();
          switch (typedKey) {
            case "replace":
              newAction.replace = value.toLowerCase() === "true";
              break;
            case "temperature":
              newAction.temperature = CREATIVITY[value] ? value : null;
              break;
            case "name":
            case "prompt":
            case "system":
            case "providerId":
              newAction[typedKey] = value;
              break;
          }
          if (typedKey === "name")
            nameFound = true;
          foundKey = true;
          break;
        }
      }
      if (!foundKey && trimmedPart) {
        logger.warn(`Quick Add: Ignoring unrecognized part: "${trimmedPart}"`);
      }
    }
    if (!nameFound || !newAction.name) {
      new import_obsidian.Notice("Quick Add Error: Action 'Name:' field is required.");
      return;
    }
    if (newAction.providerId === "")
      newAction.providerId = null;
    const existingIndex = targetGroup.actions.findIndex((a) => (a == null ? void 0 : a.name) === newAction.name);
    if (existingIndex !== -1) {
      targetGroup.actions[existingIndex] = { ...targetGroup.actions[existingIndex], ...newAction, id: targetGroup.actions[existingIndex].id, groupId: targetGroup.actions[existingIndex].groupId };
      new import_obsidian.Notice(`Action "${newAction.name}" updated in group "${targetGroup.name}".`);
    } else {
      const completeAction = { id: newAction.id, groupId: newAction.groupId, name: newAction.name, prompt: (_b = newAction.prompt) != null ? _b : "", system: (_c = newAction.system) != null ? _c : "", replace: (_d = newAction.replace) != null ? _d : false, providerId: (_e = newAction.providerId) != null ? _e : null, temperature: (_f = newAction.temperature) != null ? _f : null };
      targetGroup.actions.push(completeAction);
      new import_obsidian.Notice(`Action "${newAction.name}" added to group "${targetGroup.name}".`);
    }
    await this.plugin.saveSettings();
    textComponent.setValue("");
    this.display();
  }
  // --- Main Rendering Methods ---
  // display: Fetches providers, prepares options, and renders sections
  async display() {
    var _a;
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h1", { text: "Local GPT Settings" });
    try {
      logger.debug("Fetching AI providers for settings tab...");
      const aiSvcWaiter = await (0, import_sdk.waitForAI)();
      const aiSvc = await aiSvcWaiter.promise;
      this.availableProviders = (aiSvc.providers || []).map((p) => ({ id: p.id, name: p.model ? `${p.name} (${p.model})` : p.name })).sort((a, b) => a.name.localeCompare(b.name));
      this.prepareDropdownOptions();
      logger.debug(`Found ${this.availableProviders.length} providers.`);
      this.renderProviderSettings(containerEl.createDiv());
      containerEl.createEl("hr");
      this.renderDefaultSettings(containerEl.createDiv());
      containerEl.createEl("hr");
      const editingId = (_a = this.plugin.state) == null ? void 0 : _a.editingActionId;
      if (editingId) {
        const { action } = this.findActionAndGroup(editingId);
        if (action) {
          this.renderEditForm(containerEl.createDiv(), action);
        } else {
          logger.error(`Edit Action Error: Action ID ${editingId} not found.`);
          if (this.plugin.state)
            this.plugin.state.editingActionId = null;
          this.renderNormalView(containerEl);
        }
      } else {
        this.renderNormalView(containerEl);
      }
      containerEl.createEl("hr");
      this.renderDangerZone(containerEl.createDiv());
    } catch (error) {
      logger.error("Error displaying settings tab:", error);
      containerEl.createEl("h2", { text: "Error Loading Settings" });
      containerEl.createEl("p", { text: "Could not fetch AI providers or render settings. Check the console (Ctrl+Shift+I) for details." });
      if (error instanceof Error) {
        containerEl.createEl("pre", { text: error.message });
      }
    }
  }
  // renderNormalView: Renders sections when not editing
  renderNormalView(containerEl) {
    this.renderActionGroupManagement(containerEl.createDiv());
    this.renderQuickAdd(containerEl.createDiv());
    this.renderActionListHeader(containerEl.createDiv());
    this.renderActionList(containerEl.createDiv());
  }
  // renderProviderSettings: Section for default provider selection
  renderProviderSettings(containerEl) {
    containerEl.createEl("h2", { text: "AI Provider Settings" });
    containerEl.createEl("p", { cls: "setting-item-description", text: "Select default AI providers. Can be overridden per action." });
    new import_obsidian.Setting(containerEl).setName("Default Main Provider").addDropdown((dd) => {
      dd.addOptions(this.providerOptions).setValue(this.plugin.settings.aiProviders.main || "").onChange(async (val) => {
        this.plugin.settings.aiProviders.main = val || null;
        await this.debouncedSave();
      });
      dd.selectEl.title = this.availableProviders.map((p) => `${p.name} (ID: ${p.id})`).join("\n");
    });
    new import_obsidian.Setting(containerEl).setName("Default Embedding Provider").addDropdown((dd) => {
      dd.addOptions(this.providerOptions).setValue(this.plugin.settings.aiProviders.embedding || "").onChange(async (val) => {
        this.plugin.settings.aiProviders.embedding = val || null;
        await this.debouncedSave();
      });
      dd.selectEl.title = this.availableProviders.map((p) => `${p.name} (ID: ${p.id})`).join("\n");
    });
    new import_obsidian.Setting(containerEl).setName("Default Vision Provider").addDropdown((dd) => {
      dd.addOptions(this.providerOptions).setValue(this.plugin.settings.aiProviders.vision || "").onChange(async (val) => {
        this.plugin.settings.aiProviders.vision = val || null;
        await this.debouncedSave();
      });
      dd.selectEl.title = this.availableProviders.map((p) => `${p.name} (ID: ${p.id})`).join("\n");
    });
  }
  // renderDefaultSettings: Section for default creativity and context menu toggles
  renderDefaultSettings(containerEl) {
    containerEl.createEl("h2", { text: "Default Behavior" });
    new import_obsidian.Setting(containerEl).setName("Default Creativity").setDesc("Controls AI 'temperature'. Higher = more creative/random.").addDropdown((dd) => {
      dd.addOptions(this.creativityOptions).setValue(this.plugin.settings.defaults.creativity || "balanced").onChange(async (val) => {
        if (CREATIVITY[val]) {
          this.plugin.settings.defaults.creativity = val;
        } else {
          this.plugin.settings.defaults.creativity = DEFAULT_SETTINGS.defaults.creativity;
          dd.setValue(this.plugin.settings.defaults.creativity);
          logger.warn(`Invalid creativity key "${val}" selected, falling back to default.`);
        }
        await this.debouncedSave();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Show Provider Choice in Context Menu").setDesc("Always ask for provider via modal (like Shift+Click).").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.showProviderInContextMenu).onChange(async (val) => {
        this.plugin.settings.showProviderInContextMenu = val;
        await this.debouncedSave();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Show Creativity Choice in Context Menu").setDesc("Always ask for creativity via modal (like Shift+Click).").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.showCreativityInContextMenu).onChange(async (val) => {
        this.plugin.settings.showCreativityInContextMenu = val;
        await this.debouncedSave();
      });
    });
  }
  // renderActionGroupManagement: Section for Add/Rename/Delete groups
  renderActionGroupManagement(containerEl) {
    containerEl.createEl("h2", { text: "Action Groups" });
    new import_obsidian.Setting(containerEl).setName("Manage Action Groups").addButton((button) => {
      button.setButtonText("Add New Group").setIcon("plus-circle").onClick(async () => {
        const newId = v4_default();
        let newName = "New Group";
        let count = 1;
        while (this.plugin.settings.actionGroups.some((g) => g.name === newName)) {
          count++;
          newName = `New Group ${count}`;
        }
        const newGroup = { id: newId, name: newName, actions: [] };
        this.plugin.settings.actionGroups.push(newGroup);
        await this.plugin.saveSettings();
        this.prepareDropdownOptions();
        this.display();
        new import_obsidian.Notice(`Added group: ${newGroup.name}`);
      });
    });
    (this.plugin.settings.actionGroups || []).forEach((group, index) => {
      if (!group)
        return;
      new import_obsidian.Setting(containerEl).setName(group.name).setClass("local-gpt-settings-group-item").addButton((button) => {
        button.setTooltip("Rename Group").setIcon("pencil").onClick(() => {
          const modal = new InputModal(this.app, "Rename Group", group.name, async (newName) => {
            if (newName && newName !== group.name) {
              if (this.plugin.settings.actionGroups.some((g) => g.id !== group.id && g.name === newName.trim())) {
                new import_obsidian.Notice(`A group named "${newName.trim()}" already exists.`);
                return;
              }
              group.name = newName.trim();
              await this.plugin.saveSettings();
              this.prepareDropdownOptions();
              this.display();
              new import_obsidian.Notice(`Renamed group to: ${group.name}`);
            }
          });
          modal.open();
        });
      }).addButton((button) => {
        button.setTooltip("Delete Group").setIcon("trash").setClass("mod-warning").setDisabled(this.plugin.settings.actionGroups.length <= 1).onClick(() => {
          if (this.plugin.settings.actionGroups.length <= 1) {
            new import_obsidian.Notice("Cannot delete the last action group.");
            return;
          }
          const confirmModal = new ConfirmModal(this.app, "Delete Group?", `Are you sure you want to delete the group "${group.name}"? All actions within it will also be deleted. This cannot be undone.`, async () => {
            var _a, _b;
            this.plugin.settings.actionGroups.splice(index, 1);
            if (this.plugin.settings.currentGroupId === group.id) {
              this.plugin.settings.currentGroupId = (_b = (_a = this.plugin.settings.actionGroups[0]) == null ? void 0 : _a.id) != null ? _b : null;
            }
            await this.plugin.saveSettings();
            this.prepareDropdownOptions();
            this.display();
            new import_obsidian.Notice(`Deleted group: ${group.name}`);
          });
          confirmModal.open();
        });
      });
    });
  }
  // renderQuickAdd: Section for pasting action strings
  renderQuickAdd(containerEl) {
    var _a, _b;
    containerEl.createEl("h2", { text: "Quick Add Action" });
    const setting = new import_obsidian.Setting(containerEl).setName("Paste Action String");
    setting.descEl.appendText(`Paste a shared action string here (separated by "${QUICK_ADD_SEPARATOR}").`);
    setting.descEl.createEl("br");
    setting.descEl.appendText(`It will be added to the `);
    setting.descEl.createEl("strong", { text: `"${(_b = (_a = this.plugin.settings.actionGroups[0]) == null ? void 0 : _a.name) != null ? _b : "first"}"` });
    setting.descEl.appendText(` group.`);
    setting.descEl.createEl("br");
    setting.descEl.appendText(`If an action with the same name exists in that group, it will be `);
    setting.descEl.createEl("strong", { text: `overwritten.` });
    setting.addTextArea((text) => {
      text.inputEl.style.width = "100%";
      text.inputEl.rows = 3;
      text.setPlaceholder(`Example:
Name: My Action ${QUICK_ADD_SEPARATOR} Prompt: Do something`);
      text.onChange((0, import_obsidian.debounce)(async (value) => {
        if (value && value.includes(QUICK_ADD_SEPARATOR)) {
          await this.handleQuickAdd(value, text);
        }
      }, 300));
    });
  }
  // renderActionListHeader: Section header with Reorder/Done button
  renderActionListHeader(containerEl) {
    var _a, _b;
    containerEl.createEl("h2", { text: "Actions" });
    const reorderingGroupId = (_a = this.plugin.state) == null ? void 0 : _a.reorderingGroupId;
    const isReordering = !!reorderingGroupId;
    const currentGroupName = (_b = this.plugin.settings.actionGroups.find((g) => g.id === reorderingGroupId)) == null ? void 0 : _b.name;
    new import_obsidian.Setting(containerEl).setName(isReordering ? `Reordering "${currentGroupName != null ? currentGroupName : "Unknown Group"}"` : "Reorder Actions").setDesc(isReordering ? "Click 'Done' when finished reordering actions." : "Click to enable reordering for the selected group.").addButton((button) => {
      button.setButtonText(isReordering ? "Done" : "Reorder").setIcon(isReordering ? "check" : "move").onClick(() => {
        if (this.plugin.state) {
          this.plugin.state.reorderingGroupId = isReordering ? null : this.plugin.settings.currentGroupId;
        }
        this.display();
      });
      button.buttonEl.toggleClass("mod-cta", isReordering);
    });
  }
  // renderActionList: Renders groups and their actions
  renderActionList(containerEl) {
    var _a;
    const groups = this.plugin.settings.actionGroups || [];
    const reorderingGroupId = (_a = this.plugin.state) == null ? void 0 : _a.reorderingGroupId;
    if (!groups.length) {
      containerEl.createEl("p", { text: "No action groups defined.", cls: "setting-item-description" });
      return;
    }
    groups.forEach((group, groupIndex) => {
      if (!group)
        return;
      const groupContainer = containerEl.createDiv({ cls: "local-gpt-settings-group" });
      const isReorderingThisGroup = reorderingGroupId === group.id;
      new import_obsidian.Setting(groupContainer).setHeading().setName(group.name).addExtraButton((button) => {
        button.setIcon("plus").setTooltip(`Add new action to "${group.name}"`).onClick(() => {
          const newAction = { id: v4_default(), groupId: group.id, name: "New Action", prompt: "", system: "", replace: false, providerId: null, temperature: null };
          group.actions = group.actions || [];
          group.actions.push(newAction);
          if (this.plugin.state)
            this.plugin.state.editingActionId = newAction.id;
          this.plugin.saveSettings();
          this.display();
        });
      });
      const actions = group.actions || [];
      if (actions.length === 0) {
        groupContainer.createEl("p", { text: "No actions in this group.", cls: "local-gpt-settings-empty-group" });
      } else {
        actions.forEach((action, actionIndex) => {
          if (!action)
            return;
          this.renderActionItem(groupContainer, action, groupIndex, actionIndex, isReorderingThisGroup);
        });
      }
    });
  }
  // renderActionItem: Renders a single action row with appropriate buttons
  renderActionItem(containerEl, action, groupIndex, actionIndex, isReorderingThisGroup) {
    const setting = new import_obsidian.Setting(containerEl).setName(action.name || "Untitled Action");
    setting.descEl.appendChild(this.createActionDescriptionFragment(action));
    if (isReorderingThisGroup) {
      setting.addExtraButton((button) => {
        button.setIcon("arrow-up").setTooltip("Move up").setDisabled(actionIndex === 0).onClick(async () => {
          if (actionIndex > 0) {
            const group = this.plugin.settings.actionGroups[groupIndex];
            if (!(group == null ? void 0 : group.actions))
              return;
            [group.actions[actionIndex - 1], group.actions[actionIndex]] = [group.actions[actionIndex], group.actions[actionIndex - 1]];
            await this.plugin.saveSettings();
            this.display();
          }
        });
      }).addExtraButton((button) => {
        button.setIcon("arrow-down").setTooltip("Move down").setDisabled(actionIndex === this.plugin.settings.actionGroups[groupIndex].actions.length - 1).onClick(async () => {
          const group = this.plugin.settings.actionGroups[groupIndex];
          if (!(group == null ? void 0 : group.actions) || actionIndex >= group.actions.length - 1)
            return;
          [group.actions[actionIndex + 1], group.actions[actionIndex]] = [group.actions[actionIndex], group.actions[actionIndex + 1]];
          await this.plugin.saveSettings();
          this.display();
        });
      });
    } else {
      setting.addExtraButton((button) => {
        button.setIcon("copy").setTooltip("Copy action string").onClick(() => {
          this.copyActionToString(action);
        });
      }).addExtraButton((button) => {
        button.setIcon("pencil").setTooltip("Edit action").onClick(() => {
          if (this.plugin.state)
            this.plugin.state.editingActionId = action.id;
          this.display();
        });
      });
    }
  }
  // renderEditForm: Renders the form for editing/creating an action
  renderEditForm(containerEl, action) {
    containerEl.createEl("h2", { text: action.name ? `Edit Action: ${action.name}` : "Create New Action" });
    containerEl.addClass("local-gpt-edit-form");
    const tempAction = JSON.parse(JSON.stringify(action));
    new import_obsidian.Setting(containerEl).setName("Action Name").setDesc("Unique name (within group).").addText((text) => {
      text.setValue(tempAction.name).setPlaceholder("e.g., Summarize Selection").onChange((0, import_obsidian.debounce)((value) => {
        tempAction.name = value.trim();
      }, 300));
    });
    new import_obsidian.Setting(containerEl).setName("Group").addDropdown((dd) => {
      dd.addOptions(this.groupOptions).setValue(tempAction.groupId).onChange((value) => {
        tempAction.groupId = value;
      });
    });
    new import_obsidian.Setting(containerEl).setName("System Prompt").addTextArea((text) => {
      text.setValue(tempAction.system).setPlaceholder("e.g., You are helpful").onChange((0, import_obsidian.debounce)((value) => {
        tempAction.system = value;
      }, 300));
      text.inputEl.rows = 4;
      text.inputEl.style.width = "100%";
    });
    new import_obsidian.Setting(containerEl).setName("Action Prompt").setDesc(`Use ${SELECTION_KEYWORD} / ${CONTEXT_KEYWORD}.`).addTextArea((text) => {
      text.setValue(tempAction.prompt).setPlaceholder(`e.g., Summarize:

${SELECTION_KEYWORD}`).onChange((0, import_obsidian.debounce)((value) => {
        tempAction.prompt = value;
      }, 300));
      text.inputEl.rows = 6;
      text.inputEl.style.width = "100%";
    });
    new import_obsidian.Setting(containerEl).setName("Replace Selection").addToggle((toggle) => {
      toggle.setValue(tempAction.replace).onChange((value) => {
        tempAction.replace = value;
      });
    });
    new import_obsidian.Setting(containerEl).setName("Provider Override").addDropdown((dd) => {
      dd.addOptions(this.providerOptionsWithDefault).setValue(tempAction.providerId || "").onChange((value) => {
        tempAction.providerId = value || null;
      });
    });
    new import_obsidian.Setting(containerEl).setName("Creativity Override").addDropdown((dd) => {
      dd.addOptions(this.creativityOptionsWithDefault).setValue(tempAction.temperature || "").onChange((value) => {
        tempAction.temperature = value || null;
      });
    });
    new import_obsidian.Setting(containerEl).addButton((button) => {
      button.setButtonText("Delete Action").setIcon("trash").setClass("mod-warning").onClick(() => {
        const confirmModal = new ConfirmModal(this.app, "Delete Action?", `Delete "${action.name || "this action"}"? Cannot be undone.`, async () => {
          const { group, actionIndex } = this.findActionAndGroup(action.id);
          if (group && actionIndex > -1) {
            group.actions.splice(actionIndex, 1);
            await this.plugin.saveSettings();
            if (this.plugin.state)
              this.plugin.state.editingActionId = null;
            this.display();
            new import_obsidian.Notice(`Deleted action: ${action.name}`);
          } else {
            new import_obsidian.Notice("Error deleting action.");
          }
        });
        confirmModal.open();
      });
    }).addExtraButton((button) => {
      button.setTooltip("Cancel").setIcon("cross").onClick(() => {
        if (this.plugin.state)
          this.plugin.state.editingActionId = null;
        this.display();
      });
    }).addExtraButton((button) => {
      button.setTooltip("Save").setIcon("save");
      button.onClick(async () => {
        if (!tempAction.name) {
          new import_obsidian.Notice("Action name required.");
          return;
        }
        const targetGroup = this.plugin.settings.actionGroups.find((g) => g.id === tempAction.groupId);
        if (targetGroup && targetGroup.actions.some((a) => a.id !== tempAction.id && a.name === tempAction.name)) {
          new import_obsidian.Notice(`Name "${tempAction.name}" already used in group "${targetGroup.name}".`);
          return;
        }
        const { group: originalGroup, actionIndex } = this.findActionAndGroup(action.id);
        if (originalGroup && actionIndex > -1) {
          if (originalGroup.id !== tempAction.groupId) {
            originalGroup.actions.splice(actionIndex, 1);
            const newGroup = this.plugin.settings.actionGroups.find((g) => g.id === tempAction.groupId);
            if (newGroup) {
              newGroup.actions = newGroup.actions || [];
              newGroup.actions.push(tempAction);
            } else {
              logger.error(`Target group ${tempAction.groupId} not found during save! Reverting move.`);
              originalGroup.actions.splice(actionIndex, 0, tempAction);
              tempAction.groupId = originalGroup.id;
              new import_obsidian.Notice("Error: Could not find target group. Action not moved.");
              return;
            }
          } else {
            originalGroup.actions[actionIndex] = tempAction;
          }
          await this.plugin.saveSettings();
          if (this.plugin.state)
            this.plugin.state.editingActionId = null;
          this.display();
          new import_obsidian.Notice(`Saved action: ${tempAction.name}`);
        } else {
          logger.error(`Could not find original action (ID: ${action.id}) to save.`);
          new import_obsidian.Notice("Error finding original action. Save failed.");
          if (this.plugin.state)
            this.plugin.state.editingActionId = null;
          this.display();
        }
      });
    });
  }
  // renderDangerZone: Section for resetting settings
  renderDangerZone(containerEl) {
    containerEl.createEl("h2", { text: "Danger Zone" });
    new import_obsidian.Setting(containerEl).setName("Reset Actions").setDesc("\u{1F6A8} Reset ALL groups and actions to defaults. Cannot be undone.").addButton((button) => button.setButtonText("Reset Actions to Default").setClass("mod-warning").onClick(() => {
      const confirmModal = new ConfirmModal(this.app, "Reset All Actions?", "Reset all actions/groups to defaults? All customizations lost.", async () => {
        var _a, _b;
        const defaultGroups = JSON.parse(JSON.stringify(DEFAULT_SETTINGS.actionGroups));
        defaultGroups.forEach((group) => {
          group.id = v4_default();
          group.actions.forEach((action) => {
            action.id = v4_default();
            action.groupId = group.id;
          });
        });
        this.plugin.settings.actionGroups = defaultGroups;
        this.plugin.settings.currentGroupId = (_b = (_a = defaultGroups[0]) == null ? void 0 : _a.id) != null ? _b : null;
        if (this.plugin.state) {
          this.plugin.state.editingActionId = null;
          this.plugin.state.reorderingGroupId = null;
        }
        await this.plugin.saveSettings();
        this.prepareDropdownOptions();
        this.display();
        new import_obsidian.Notice("All actions reset to defaults.");
      });
      confirmModal.open();
    }));
  }
};

// src/spinnerPlugin.ts
var import_state = require("@codemirror/state");
var import_view = require("@codemirror/view");
var import_obsidian2 = require("obsidian");
var GeneratingWidget = class extends import_view.WidgetType {
  constructor() {
    super(...arguments);
    this.dom = null;
  }
  toDOM(view) {
    if (!this.dom) {
      this.dom = document.createElement("div");
      this.dom.addClass("local-gpt-generating-container");
      this.dom.appendChild(document.createElement("br"));
      const innerContainer = this.dom.createSpan({ cls: "local-gpt-generating-inner" });
      const iconEl = innerContainer.createSpan({ cls: "local-gpt-generating-icon" });
      (0, import_obsidian2.setIcon)(iconEl, "loader");
      innerContainer.createSpan({
        cls: "local-gpt-generating-text",
        text: "Generating",
        attr: { "data-text": "Generating" }
      });
    }
    return this.dom;
  }
};
var ThinkingWidget = class extends import_view.WidgetType {
  constructor() {
    super(...arguments);
    this.dom = null;
  }
  toDOM(view) {
    if (!this.dom) {
      this.dom = document.createElement("div");
      this.dom.addClass("local-gpt-thinking-container");
      this.dom.appendChild(document.createElement("br"));
      const innerContainer = this.dom.createSpan({ cls: "local-gpt-thinking-inner" });
      innerContainer.createSpan({ cls: "local-gpt-thinking-icon", text: "\u{1F9E0}" });
      innerContainer.createSpan({
        cls: "local-gpt-thinking-text",
        text: "Thinking",
        attr: { "data-text": "Thinking" }
      });
    }
    return this.dom;
  }
};
var ContentWidget = class extends import_view.WidgetType {
  constructor(initialText) {
    super();
    this.dom = null;
    this.currentText = "";
    this.currentText = initialText;
  }
  eq(other) {
    return other.currentText === this.currentText;
  }
  updateText(newText, view) {
    if (this.currentText === newText)
      return;
    this.currentText = newText;
    if (this.dom) {
      this.dom.textContent = this.currentText;
      this.dom.classList.remove("local-gpt-streaming-animate");
      void this.dom.offsetWidth;
      this.dom.classList.add("local-gpt-streaming-animate");
    }
  }
  toDOM(view) {
    if (!this.dom) {
      this.dom = document.createElement("div");
      this.dom.classList.add("local-gpt-content");
      this.dom.setAttribute("role", "document");
      this.dom.textContent = this.currentText;
      this.dom.classList.add("local-gpt-streaming-animate");
    }
    return this.dom;
  }
};
var SpinnerPlugin = class {
  constructor(editorView) {
    this.editorView = editorView;
    this.positions = /* @__PURE__ */ new Map();
    this.decorations = import_view.Decoration.none;
    logger.debug("SpinnerPlugin initialized.");
  }
  show(position) {
    if (this.positions.has(position)) {
      logger.warn(`Spinner already exists at position ${position}.`);
      return () => {
      };
    }
    const isEndOfLine = this.isPositionAtEndOfLine(this.editorView.state, position);
    this.positions.set(position, {
      widget: new GeneratingWidget(),
      isEndOfLine,
      isThinking: false
    });
    logger.debug(`Showing spinner (Generating...) at position ${position}`);
    this.updateDecorations(true);
    return () => this.hide(position);
  }
  hide(position) {
    if (this.positions.has(position)) {
      logger.debug(`Hiding spinner at position ${position}`);
      this.positions.delete(position);
      this.updateDecorations(true);
    } else {
      logger.warn(`Attempted to hide spinner at position ${position}, but none found.`);
    }
  }
  showThinking(enabled, position) {
    let updated = false;
    const updateEntry = (data, pos) => {
      if (!(data.widget instanceof ContentWidget)) {
        if (enabled && !data.isThinking) {
          data.widget = new ThinkingWidget();
          data.isThinking = true;
          updated = true;
        } else if (!enabled && data.isThinking) {
          data.widget = new GeneratingWidget();
          data.isThinking = false;
          updated = true;
        }
      } else {
        if (data.isThinking !== enabled) {
          data.isThinking = enabled;
        }
      }
    };
    if (position !== void 0) {
      const data = this.positions.get(position);
      if (data)
        updateEntry(data, position);
      else
        logger.warn(`showThinking called for unknown position ${position}`);
    } else {
      this.positions.forEach(updateEntry);
    }
    if (updated) {
      logger.debug(`Updating thinking state display: ${enabled}`);
      this.updateDecorations(true);
    }
  }
  updateContent(text, position) {
    let widgetChanged = false;
    let contentChanged = false;
    const updateEntry = (data, pos) => {
      if (!(data.widget instanceof ContentWidget)) {
        data.widget = new ContentWidget(text);
        data.isThinking = false;
        widgetChanged = true;
        contentChanged = true;
      } else {
        const tempWidget = new ContentWidget(text);
        if (!data.widget.eq(tempWidget)) {
          data.widget.updateText(text, this.editorView);
          contentChanged = true;
        }
      }
    };
    if (position !== void 0) {
      const data = this.positions.get(position);
      if (data)
        updateEntry(data, position);
      else
        logger.warn(`updateContent called for unknown position ${position}`);
    } else {
      this.positions.forEach(updateEntry);
    }
    if (widgetChanged || contentChanged) {
      this.updateDecorations(widgetChanged || contentChanged);
    }
  }
  update(update) {
    let needsRedraw = false;
    if (update.docChanged) {
      const updatedPositions = /* @__PURE__ */ new Map();
      this.positions.forEach((data, oldPos) => {
        const newPos = update.changes.mapPos(oldPos, -1, 1);
        if (newPos !== null) {
          updatedPositions.set(newPos, data);
        } else {
          logger.debug(`Spinner position ${oldPos} deleted due to document changes.`);
          needsRedraw = true;
        }
      });
      if (updatedPositions.size !== this.positions.size || ![...updatedPositions.keys()].every((key) => this.positions.has(key))) {
        needsRedraw = true;
      }
      this.positions = updatedPositions;
    }
    if (update.viewportChanged) {
      needsRedraw = true;
    }
    if (this.positions.size === 0 && this.decorations.size > 0) {
      needsRedraw = true;
    }
    if (needsRedraw) {
      this.updateDecorations();
    }
  }
  updateDecorations(force = false) {
    const builder = new import_state.RangeSetBuilder();
    this.positions.forEach((data, position) => {
      builder.add(
        position,
        position,
        import_view.Decoration.widget({
          widget: data.widget,
          side: data.isEndOfLine ? 1 : -1,
          block: !(data.widget instanceof GeneratingWidget)
        })
      );
    });
    const newDecorations = builder.finish();
    const changed = this.decorations.size !== newDecorations.size || this.decorations.size > 0 && newDecorations.size === 0 || this.decorations.size === 0 && newDecorations.size > 0;
    if (force || changed) {
      this.decorations = newDecorations;
      this.editorView.requestMeasure();
    }
  }
  isPositionAtEndOfLine(state, position) {
    try {
      const clampedPos = Math.max(0, Math.min(position, state.doc.length));
      return clampedPos === state.doc.lineAt(clampedPos).to;
    } catch (e) {
      logger.error(`Error checking endOfLine for pos ${position}:`, e);
      return false;
    }
  }
  destroy() {
    logger.debug("SpinnerPlugin destroyed.");
    this.positions.clear();
    this.decorations = import_view.Decoration.none;
  }
};
var spinnerPlugin = import_view.ViewPlugin.fromClass(SpinnerPlugin, {
  decorations: (v) => v.decorations
});

// src/text-processing.ts
function removeThinkingTags(text) {
  if (!text)
    return "";
  return text.replace(/^\s*<think>[\s\S]*?<\/think>\s*/, "");
}

// src/utils.ts
function preparePrompt(prompt = "", selectedText, context) {
  let finalPrompt = prompt || "";
  if (finalPrompt.includes(SELECTION_KEYWORD)) {
    finalPrompt = finalPrompt.replace(SELECTION_KEYWORD, selectedText || "");
  } else if (selectedText) {
    finalPrompt = `${finalPrompt}

---

${selectedText}`;
  }
  const hasContextKeyword = finalPrompt.includes(CONTEXT_KEYWORD);
  const hasContextCondition = finalPrompt.includes(CONTEXT_CONDITION_START) && finalPrompt.includes(CONTEXT_CONDITION_END);
  const contextIsNotEmpty = context && context.trim().length > 0;
  if (hasContextCondition) {
    const startIndex = finalPrompt.indexOf(CONTEXT_CONDITION_START);
    const endIndex = finalPrompt.indexOf(CONTEXT_CONDITION_END);
    if (startIndex !== -1 && endIndex !== -1 && startIndex < endIndex) {
      const prefix = finalPrompt.substring(0, startIndex);
      const suffix = finalPrompt.substring(endIndex + CONTEXT_CONDITION_END.length);
      let conditionalBlock = finalPrompt.substring(startIndex + CONTEXT_CONDITION_START.length, endIndex);
      if (contextIsNotEmpty) {
        if (conditionalBlock.includes(CONTEXT_KEYWORD)) {
          conditionalBlock = conditionalBlock.replace(CONTEXT_KEYWORD, context);
        }
        finalPrompt = prefix + conditionalBlock + suffix;
      } else {
        finalPrompt = prefix + suffix;
      }
    } else {
      logger.warn("Mismatched or invalid context condition tags found. Ignoring conditional logic.");
      if (hasContextKeyword) {
        finalPrompt = finalPrompt.replace(CONTEXT_KEYWORD, context || "");
      } else if (contextIsNotEmpty) {
        finalPrompt = `${finalPrompt}

---
Context:
${context}`;
      }
    }
  } else if (hasContextKeyword) {
    finalPrompt = finalPrompt.replace(CONTEXT_KEYWORD, context || "");
  } else if (contextIsNotEmpty) {
    finalPrompt = `${finalPrompt}

---
Context:
${context}`;
  }
  return finalPrompt.trim();
}

// node_modules/idb/build/index.js
var instanceOfAny = (object, constructors) => constructors.some((c) => object instanceof c);
var idbProxyableTypes;
var cursorAdvanceMethods;
function getIdbProxyableTypes() {
  return idbProxyableTypes || (idbProxyableTypes = [
    IDBDatabase,
    IDBObjectStore,
    IDBIndex,
    IDBCursor,
    IDBTransaction
  ]);
}
function getCursorAdvanceMethods() {
  return cursorAdvanceMethods || (cursorAdvanceMethods = [
    IDBCursor.prototype.advance,
    IDBCursor.prototype.continue,
    IDBCursor.prototype.continuePrimaryKey
  ]);
}
var transactionDoneMap = /* @__PURE__ */ new WeakMap();
var transformCache = /* @__PURE__ */ new WeakMap();
var reverseTransformCache = /* @__PURE__ */ new WeakMap();
function promisifyRequest(request) {
  const promise = new Promise((resolve, reject) => {
    const unlisten = () => {
      request.removeEventListener("success", success);
      request.removeEventListener("error", error);
    };
    const success = () => {
      resolve(wrap(request.result));
      unlisten();
    };
    const error = () => {
      reject(request.error);
      unlisten();
    };
    request.addEventListener("success", success);
    request.addEventListener("error", error);
  });
  reverseTransformCache.set(promise, request);
  return promise;
}
function cacheDonePromiseForTransaction(tx) {
  if (transactionDoneMap.has(tx))
    return;
  const done = new Promise((resolve, reject) => {
    const unlisten = () => {
      tx.removeEventListener("complete", complete);
      tx.removeEventListener("error", error);
      tx.removeEventListener("abort", error);
    };
    const complete = () => {
      resolve();
      unlisten();
    };
    const error = () => {
      reject(tx.error || new DOMException("AbortError", "AbortError"));
      unlisten();
    };
    tx.addEventListener("complete", complete);
    tx.addEventListener("error", error);
    tx.addEventListener("abort", error);
  });
  transactionDoneMap.set(tx, done);
}
var idbProxyTraps = {
  get(target, prop, receiver) {
    if (target instanceof IDBTransaction) {
      if (prop === "done")
        return transactionDoneMap.get(target);
      if (prop === "store") {
        return receiver.objectStoreNames[1] ? void 0 : receiver.objectStore(receiver.objectStoreNames[0]);
      }
    }
    return wrap(target[prop]);
  },
  set(target, prop, value) {
    target[prop] = value;
    return true;
  },
  has(target, prop) {
    if (target instanceof IDBTransaction && (prop === "done" || prop === "store")) {
      return true;
    }
    return prop in target;
  }
};
function replaceTraps(callback) {
  idbProxyTraps = callback(idbProxyTraps);
}
function wrapFunction(func) {
  if (getCursorAdvanceMethods().includes(func)) {
    return function(...args) {
      func.apply(unwrap(this), args);
      return wrap(this.request);
    };
  }
  return function(...args) {
    return wrap(func.apply(unwrap(this), args));
  };
}
function transformCachableValue(value) {
  if (typeof value === "function")
    return wrapFunction(value);
  if (value instanceof IDBTransaction)
    cacheDonePromiseForTransaction(value);
  if (instanceOfAny(value, getIdbProxyableTypes()))
    return new Proxy(value, idbProxyTraps);
  return value;
}
function wrap(value) {
  if (value instanceof IDBRequest)
    return promisifyRequest(value);
  if (transformCache.has(value))
    return transformCache.get(value);
  const newValue = transformCachableValue(value);
  if (newValue !== value) {
    transformCache.set(value, newValue);
    reverseTransformCache.set(newValue, value);
  }
  return newValue;
}
var unwrap = (value) => reverseTransformCache.get(value);
function openDB(name, version, { blocked, upgrade, blocking, terminated } = {}) {
  const request = indexedDB.open(name, version);
  const openPromise = wrap(request);
  if (upgrade) {
    request.addEventListener("upgradeneeded", (event) => {
      upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction), event);
    });
  }
  if (blocked) {
    request.addEventListener("blocked", (event) => blocked(
      // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405
      event.oldVersion,
      event.newVersion,
      event
    ));
  }
  openPromise.then((db) => {
    if (terminated)
      db.addEventListener("close", () => terminated());
    if (blocking) {
      db.addEventListener("versionchange", (event) => blocking(event.oldVersion, event.newVersion, event));
    }
  }).catch(() => {
  });
  return openPromise;
}
var readMethods = ["get", "getKey", "getAll", "getAllKeys", "count"];
var writeMethods = ["put", "add", "delete", "clear"];
var cachedMethods = /* @__PURE__ */ new Map();
function getMethod(target, prop) {
  if (!(target instanceof IDBDatabase && !(prop in target) && typeof prop === "string")) {
    return;
  }
  if (cachedMethods.get(prop))
    return cachedMethods.get(prop);
  const targetFuncName = prop.replace(/FromIndex$/, "");
  const useIndex = prop !== targetFuncName;
  const isWrite = writeMethods.includes(targetFuncName);
  if (
    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.
    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) || !(isWrite || readMethods.includes(targetFuncName))
  ) {
    return;
  }
  const method = async function(storeName, ...args) {
    const tx = this.transaction(storeName, isWrite ? "readwrite" : "readonly");
    let target2 = tx.store;
    if (useIndex)
      target2 = target2.index(args.shift());
    return (await Promise.all([
      target2[targetFuncName](...args),
      isWrite && tx.done
    ]))[0];
  };
  cachedMethods.set(prop, method);
  return method;
}
replaceTraps((oldTraps) => ({
  ...oldTraps,
  get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),
  has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop)
}));
var advanceMethodProps = ["continue", "continuePrimaryKey", "advance"];
var methodMap = {};
var advanceResults = /* @__PURE__ */ new WeakMap();
var ittrProxiedCursorToOriginalProxy = /* @__PURE__ */ new WeakMap();
var cursorIteratorTraps = {
  get(target, prop) {
    if (!advanceMethodProps.includes(prop))
      return target[prop];
    let cachedFunc = methodMap[prop];
    if (!cachedFunc) {
      cachedFunc = methodMap[prop] = function(...args) {
        advanceResults.set(this, ittrProxiedCursorToOriginalProxy.get(this)[prop](...args));
      };
    }
    return cachedFunc;
  }
};
async function* iterate(...args) {
  let cursor = this;
  if (!(cursor instanceof IDBCursor)) {
    cursor = await cursor.openCursor(...args);
  }
  if (!cursor)
    return;
  cursor = cursor;
  const proxiedCursor = new Proxy(cursor, cursorIteratorTraps);
  ittrProxiedCursorToOriginalProxy.set(proxiedCursor, cursor);
  reverseTransformCache.set(proxiedCursor, unwrap(cursor));
  while (cursor) {
    yield proxiedCursor;
    cursor = await (advanceResults.get(proxiedCursor) || cursor.continue());
    advanceResults.delete(proxiedCursor);
  }
}
function isIteratorProp(target, prop) {
  return prop === Symbol.asyncIterator && instanceOfAny(target, [IDBIndex, IDBObjectStore, IDBCursor]) || prop === "iterate" && instanceOfAny(target, [IDBIndex, IDBObjectStore]);
}
replaceTraps((oldTraps) => ({
  ...oldTraps,
  get(target, prop, receiver) {
    if (isIteratorProp(target, prop))
      return iterate;
    return oldTraps.get(target, prop, receiver);
  },
  has(target, prop) {
    return isIteratorProp(target, prop) || oldTraps.has(target, prop);
  }
}));

// src/indexedDB.ts
var FileCache = class {
  constructor() {
    this.db = null;
    // Let TypeScript infer types for simple string initializations
    this.vaultId = "";
    this.dbName = "";
  }
  async init(vaultId) {
    this.vaultId = vaultId;
    this.dbName = `LocalGPTCache/${this.vaultId}`;
    logger.debug(`Initializing IndexedDB: ${this.dbName}`);
    try {
      this.db = await openDB(this.dbName, 2, {
        upgrade(db, oldVersion, newVersion, transaction, event) {
          logger.info(`Upgrading IndexedDB '${db.name}' from v${oldVersion} to v${newVersion}`);
          if (oldVersion < 1) {
            logger.debug("Creating 'embeddings' object store");
            db.createObjectStore("embeddings");
          }
          if (oldVersion < 2) {
            logger.debug("Creating 'content' object store");
            if (!db.objectStoreNames.contains("content")) {
              db.createObjectStore("content");
            } else {
              logger.debug("'content' object store already exists.");
            }
          }
          logger.info(`IndexedDB upgrade to v${newVersion} complete.`);
        },
        blocked(currentVersion, blockedVersion, event) {
          logger.error(`Local GPT IndexedDB open is blocked. Current: v${currentVersion}, Attempting: v${blockedVersion}. Close other tabs/windows.`);
        },
        blocking(currentVersion, blockedVersion, event) {
          logger.warn(`Local GPT IndexedDB is blocking upgrade. Current: v${currentVersion}, Blocked: v${blockedVersion}. Consider reloading.`);
        },
        terminated() {
          logger.error("Local GPT IndexedDB: Database connection terminated unexpectedly.");
          this.db = null;
        }
      });
      logger.info(`Local GPT IndexedDB '${this.dbName}' opened successfully.`);
    } catch (error) {
      logger.error(`Local GPT: Failed to open IndexedDB '${this.dbName}':`, error);
      this.db = null;
    }
  }
  async ensureDb() {
    if (!this.db) {
      logger.warn("IndexedDB: Database not initialized or connection lost. Re-init attempt.");
      if (!this.vaultId) {
        throw new Error("IndexedDB: Vault ID not set, cannot re-initialize.");
      }
      await this.init(this.vaultId);
      if (!this.db) {
        throw new Error("IndexedDB: Re-initialization failed.");
      }
    }
    return this.db;
  }
  async getEmbeddings(key) {
    try {
      const db = await this.ensureDb();
      return await db.get("embeddings", key);
    } catch (error) {
      logger.error(`IndexedDB Get Embeddings Error (key: "${key}"):`, error);
      return void 0;
    }
  }
  async setEmbeddings(key, value) {
    try {
      const db = await this.ensureDb();
      const tx = db.transaction("embeddings", "readwrite");
      await tx.store.put(value, key);
      await tx.done;
    } catch (error) {
      logger.error(`IndexedDB Set Embeddings Error (key: "${key}"):`, error);
    }
  }
  async getContent(key) {
    try {
      const db = await this.ensureDb();
      if (!db.objectStoreNames.contains("content"))
        return void 0;
      return await db.get("content", key);
    } catch (error) {
      logger.error(`IndexedDB Get Content Error (key: "${key}"):`, error);
      return void 0;
    }
  }
  async setContent(key, value) {
    try {
      const db = await this.ensureDb();
      if (!db.objectStoreNames.contains("content")) {
        logger.error(`IndexedDB Set Content Error: Store 'content' not found.`);
        return;
      }
      const tx = db.transaction("content", "readwrite");
      await tx.store.put(value, key);
      await tx.done;
    } catch (error) {
      logger.error(`IndexedDB Set Content Error (key: "${key}"):`, error);
    }
  }
  async clearEmbeddings() {
    try {
      const db = await this.ensureDb();
      if (!db.objectStoreNames.contains("embeddings"))
        return;
      await db.clear("embeddings");
      logger.info("IndexedDB: Embeddings cache cleared.");
    } catch (error) {
      logger.error(`IndexedDB Clear Embeddings Error:`, error);
    }
  }
  async clearContent() {
    try {
      const db = await this.ensureDb();
      if (!db.objectStoreNames.contains("content"))
        return;
      await db.clear("content");
      logger.info("IndexedDB: Content cache cleared.");
    } catch (error) {
      logger.error(`IndexedDB Clear Content Error:`, error);
    }
  }
  async clearAll() {
    logger.warn("Clearing ALL IndexedDB caches...");
    await Promise.all([
      this.clearEmbeddings(),
      this.clearContent()
    ]).catch((error) => {
      logger.error("Error during clearAll:", error);
    });
    logger.info("IndexedDB: All known caches cleared.");
  }
};
var fileCache = new FileCache();

// src/main.ts
var ProviderSuggestModal = class extends import_obsidian3.SuggestModal {
  constructor(app, providers, onSubmit) {
    super(app);
    const defaultChoice = { id: "__DEFAULT__", name: "Default (Use Setting)", type: "ollama", model: "", isDefault: true };
    const uniqueSdkProviders = providers.filter((p) => p && p.id !== "__DEFAULT__");
    this.providers = [defaultChoice, ...uniqueSdkProviders.map((p) => ({ ...p, id: p.id }))];
    this.onSubmit = onSubmit;
    this.setPlaceholder("Select Provider (or ESC to cancel)...");
  }
  getSuggestions(query) {
    const lowerQuery = query.toLowerCase();
    return this.providers.filter((p) => {
      var _a, _b;
      return ((_a = p.name) == null ? void 0 : _a.toLowerCase().includes(lowerQuery)) || ((_b = p.id) == null ? void 0 : _b.toLowerCase().includes(lowerQuery)) || p.isDefault && "default".toLowerCase().includes(lowerQuery);
    });
  }
  renderSuggestion(provider, el) {
    el.createEl("div", { text: provider.name });
    const descEl = el.createEl("small", { cls: "plugin-suggestion-description" });
    if (provider.isDefault) {
      descEl.setText("Uses global or action-specific setting");
    } else {
      const details = [];
      if (provider.model)
        details.push(`M: ${provider.model}`);
      if (provider.id && provider.id !== provider.name && provider.id !== "__DEFAULT__") {
        details.push(`ID: ${provider.id}`);
      }
      descEl.setText(details.join(" | "));
    }
  }
  onChooseSuggestion(provider, evt) {
    this.onSubmit(provider);
  }
};
var CreativitySuggestModal = class extends import_obsidian3.SuggestModal {
  constructor(app, choices, onSubmit) {
    super(app);
    this.choices = choices;
    this.onSubmit = onSubmit;
    this.setPlaceholder("Select Creativity (or ESC to cancel)...");
  }
  getSuggestions(query) {
    const lowerQuery = query.toLowerCase();
    return this.choices.filter((c) => c.name.toLowerCase().includes(lowerQuery) || c.key.toLowerCase().includes(lowerQuery));
  }
  renderSuggestion(choice, el) {
    el.createEl("div", { text: choice.name });
    if (choice.isDefault) {
      el.createEl("small", { text: "Uses global or action-specific setting", cls: "plugin-suggestion-description" });
    }
  }
  onChooseSuggestion(choice, evt) {
    this.onSubmit(choice);
  }
};
var LocalGPT = class extends import_obsidian3.Plugin {
  constructor(app, manifest) {
    super(app, manifest);
    this.abortControllers = [];
    this.contextMenuCurrentGroupId = null;
    /** Handles the Escape key to abort ongoing actions */
    this.escapeHandler = (event) => {
      if (event.key === "Escape") {
        if (this.abortControllers.length > 0) {
          logger.warn(`Escape key pressed. Aborting ${this.abortControllers.length} active action(s).`);
          const controllersToAbort = [...this.abortControllers];
          controllersToAbort.forEach((controller) => {
            try {
              if (!controller.signal.aborted) {
                controller.abort();
              }
            } catch (e) {
              logger.error("Error aborting controller on ESC:", e);
            }
          });
          this.abortControllers = [];
        }
      }
    };
  }
  async onload() {
    logger.info(`Loading Local GPT Plugin v${this.manifest.version}...`);
    try {
      await (0, import_sdk2.initAI)(this.app, this, async () => {
        var _a, _b, _c, _d;
        await this.loadSettings();
        this.addSettingTab(new LocalGPTSettingTab(this.app, this));
        const firstValidGroupId = (_c = (_b = (_a = this.settings.actionGroups) == null ? void 0 : _a.find((g) => g == null ? void 0 : g.id)) == null ? void 0 : _b.id) != null ? _c : null;
        if (!this.settings.currentGroupId || !((_d = this.settings.actionGroups) == null ? void 0 : _d.some((g) => g.id === this.settings.currentGroupId))) {
          this.settings.currentGroupId = firstValidGroupId;
          if (firstValidGroupId)
            await this.saveSettings();
        }
        this.contextMenuCurrentGroupId = this.settings.currentGroupId;
        this.state = { editingActionId: null, reorderingGroupId: null };
        this.reload();
        this.app.workspace.onLayoutReady(async () => {
          var _a2, _b2;
          try {
            const vaultId = this.app.appId || ((_a2 = this.app.vault) == null ? void 0 : _a2.configDir) || ((_b2 = this.app.vault) == null ? void 0 : _b2.getName()) || "default-vault";
            await fileCache.init(vaultId);
            logger.info(`File cache initialized for vault: ${vaultId}`);
          } catch (err) {
            logger.error("Failed to init file cache:", err);
            new import_obsidian3.Notice("Local GPT: Failed to initialize file cache.");
          }
        });
        this.registerEditorExtension(spinnerPlugin);
        logger.debug("SpinnerPlugin registered.");
        document.addEventListener("keydown", this.escapeHandler);
        logger.info("Local GPT Plugin Loaded Successfully.");
      });
    } catch (err) {
      logger.error("Error initializing AI Providers SDK or loading plugin:", err);
      new import_obsidian3.Notice("Local GPT Error: Could not initialize AI Providers. Check settings or console.", 0);
    }
  }
  /** Reloads commands and resets abort controllers */
  reload() {
    logger.debug("Reloading Local GPT commands...");
    this.abortControllers.forEach((controller) => {
      try {
        controller.abort();
      } catch (e) {
        logger.warn("Error aborting controller during reload:", e);
      }
    });
    this.abortControllers = [];
    this.addCommands();
    document.removeEventListener("keydown", this.escapeHandler);
    document.addEventListener("keydown", this.escapeHandler);
    logger.debug("Local GPT Reloaded.");
  }
  /** Registers plugin commands */
  addCommands() {
    var _a;
    logger.debug("Registering commands...");
    this.addCommand({
      id: "local-gpt-context-menu",
      name: "Local GPT: Show Actions...",
      editorCallback: (editor) => {
        this.contextMenuCurrentGroupId = this.settings.currentGroupId;
        this.showActionContextMenu(editor);
      }
    });
    const currentActiveGroup = (_a = this.settings.actionGroups) == null ? void 0 : _a.find((g) => (g == null ? void 0 : g.id) === this.settings.currentGroupId);
    if (currentActiveGroup == null ? void 0 : currentActiveGroup.actions) {
      logger.info(`Registering hotkey commands for action group: "${currentActiveGroup.name}"`);
      currentActiveGroup.actions.forEach((action) => {
        if (!(action == null ? void 0 : action.id) || !action.name)
          return;
        const commandId = `local-gpt-action-${action.id}`;
        const commandName = `Local GPT: ${currentActiveGroup.name} - ${action.name}`;
        this.addCommand({
          id: commandId,
          name: commandName,
          editorCallback: (editor) => {
            logger.info(`Running action via hotkey: ${commandName}`);
            this.runAction(action, editor);
          }
        });
      });
    } else {
      logger.debug("No current active group selected or group has no actions. No action hotkey commands registered.");
    }
  }
  /** Builds and displays the context menu */
  showActionContextMenu(editor) {
    var _a, _b, _c;
    const editorView = editor.cm;
    if (!editorView) {
      logger.error("Could not get CodeMirror view (cm).");
      return;
    }
    const groups = this.settings.actionGroups;
    if (!(groups == null ? void 0 : groups.length)) {
      new import_obsidian3.Notice("No action groups configured.");
      return;
    }
    let currentGroupId = (_a = this.contextMenuCurrentGroupId) != null ? _a : this.settings.currentGroupId;
    let currentGroupIndex = groups.findIndex((g) => (g == null ? void 0 : g.id) === currentGroupId);
    if (currentGroupIndex === -1) {
      currentGroupId = (_c = (_b = groups[0]) == null ? void 0 : _b.id) != null ? _c : null;
      currentGroupIndex = 0;
      this.contextMenuCurrentGroupId = currentGroupId;
    }
    const currentGroup = groups[currentGroupIndex];
    if (!currentGroup || !currentGroupId) {
      new import_obsidian3.Notice("Error finding current action group.");
      return;
    }
    const contextMenu = new import_obsidian3.Menu();
    contextMenu.addItem((item) => {
      item.setTitle(`Group: ${currentGroup.name}`).setIcon("folder-open").setDisabled(true).setIsLabel(true);
    });
    contextMenu.addItem((item) => {
      item.setTitle("Shift-click an action for options").setIcon("info").setDisabled(true).setIsLabel(true);
    });
    if (groups.length > 1) {
      contextMenu.addSeparator();
      contextMenu.addItem((item) => {
        item.setTitle("\u2B05\uFE0F Previous Group").setIcon("arrow-left").onClick((evt) => {
          var _a2, _b2;
          evt.stopPropagation();
          const newIndex = (currentGroupIndex - 1 + groups.length) % groups.length;
          this.contextMenuCurrentGroupId = (_b2 = (_a2 = groups[newIndex]) == null ? void 0 : _a2.id) != null ? _b2 : null;
          this.showActionContextMenu(editor);
        });
      });
      contextMenu.addItem((item) => {
        item.setTitle("Next Group \u27A1\uFE0F").setIcon("arrow-right").onClick((evt) => {
          var _a2, _b2;
          evt.stopPropagation();
          const newIndex = (currentGroupIndex + 1) % groups.length;
          this.contextMenuCurrentGroupId = (_b2 = (_a2 = groups[newIndex]) == null ? void 0 : _a2.id) != null ? _b2 : null;
          this.showActionContextMenu(editor);
        });
      });
      contextMenu.addSeparator();
    } else {
      contextMenu.addSeparator();
    }
    if (!currentGroup.actions || currentGroup.actions.length === 0) {
      contextMenu.addItem((item) => item.setTitle("No actions in this group").setDisabled(true));
    } else {
      currentGroup.actions.forEach((action) => {
        if (!action)
          return;
        contextMenu.addItem((item) => {
          item.setTitle(action.name).setIcon(action.replace ? "replace" : "plus-circle").onClick(async (evt) => {
            var _a2, _b2;
            let hideSpinnerOnClick = null;
            const cmOnClick = editor.cm;
            const spinnerOnClick = cmOnClick == null ? void 0 : cmOnClick.plugin(spinnerPlugin);
            if (spinnerOnClick) {
              try {
                const pos = editor.posToOffset(editor.getCursor("to"));
                hideSpinnerOnClick = spinnerOnClick.show(pos);
              } catch (e) {
                logger.error("Error showing spinner on click:", e);
              }
            }
            const shiftPressed = evt.shiftKey;
            let temporaryProviderId = void 0;
            let temporaryTemperatureKey = void 0;
            let cancelled = false;
            const showProviderToggle = (_a2 = this.settings.showProviderInContextMenu) != null ? _a2 : false;
            const showCreativityToggle = (_b2 = this.settings.showCreativityInContextMenu) != null ? _b2 : false;
            if (shiftPressed || showProviderToggle) {
              temporaryProviderId = await this.promptForProviderOverride();
              if (temporaryProviderId === void 0)
                cancelled = true;
            }
            if (!cancelled && (shiftPressed || showCreativityToggle)) {
              temporaryTemperatureKey = await this.promptForCreativityOverride();
              if (temporaryTemperatureKey === void 0)
                cancelled = true;
            }
            if (cancelled) {
              logger.warn(`Action "${action.name}" run cancelled due to override selection.`);
              if (hideSpinnerOnClick) {
                try {
                  hideSpinnerOnClick();
                } catch (e) {
                }
              }
              return;
            }
            logger.info(`Running action "${action.name}" from context menu. Shift: ${shiftPressed}, ProvOverride: ${temporaryProviderId === void 0 ? "Not Prompted" : temporaryProviderId != null ? temporaryProviderId : "Selected Default"}, TempOverride: ${temporaryTemperatureKey === void 0 ? "Not Prompted" : temporaryTemperatureKey != null ? temporaryTemperatureKey : "Selected Default"}`);
            if (hideSpinnerOnClick) {
              try {
                hideSpinnerOnClick();
              } catch (e) {
              }
            }
            this.runAction(action, editor, temporaryProviderId, temporaryTemperatureKey);
          });
        });
      });
    }
    contextMenu.showAtPosition(this.getMenuPosition(editorView, editor));
  }
  /** Prompts user to select a provider via modal */
  async promptForProviderOverride() {
    logger.debug("Prompting for provider override...");
    try {
      const aiSvcWaiter = await (0, import_sdk2.waitForAI)();
      const aiSvc = await aiSvcWaiter.promise;
      const allProviders = aiSvc.providers || [];
      if (!(allProviders == null ? void 0 : allProviders.length)) {
        new import_obsidian3.Notice("No AI providers available.");
        return void 0;
      }
      const choices = [
        { id: "__DEFAULT__", name: "Default (Use Setting)", type: "ollama", model: "", isDefault: true },
        // Explicit default option
        // Filter SDK list for potential bad entries or duplicates of the explicit default
        ...allProviders.filter((p) => p && p.id && p.id !== "__DEFAULT__").map((p) => ({ ...p }))
      ];
      const selectedProvider = await new Promise((resolve) => {
        new ProviderSuggestModal(this.app, choices, resolve).open();
      });
      if (selectedProvider === null) {
        logger.debug("Provider selection cancelled or closed.");
        return void 0;
      } else if (selectedProvider.id === "__DEFAULT__") {
        logger.debug("Default provider selected in override.");
        return null;
      } else {
        logger.debug(`Override provider selected: ${selectedProvider.id}`);
        return selectedProvider.id;
      }
    } catch (err) {
      logger.error("Error showing provider selection modal:", err);
      new import_obsidian3.Notice("Could not show provider selection.");
      return void 0;
    }
  }
  /** Prompts user to select a creativity level via modal */
  async promptForCreativityOverride() {
    logger.debug("Prompting for creativity override...");
    try {
      const choices = [
        { key: "__DEFAULT__", name: "Default (Use Setting)", isDefault: true },
        ...Object.entries(CREATIVITY).map(([key, value]) => ({
          key,
          name: `${key.charAt(0).toUpperCase() + key.slice(1)} (~${value.temperature.toFixed(1)})`
        }))
      ];
      const selectedCreativity = await new Promise((resolve) => {
        new CreativitySuggestModal(this.app, choices, resolve).open();
      });
      if (selectedCreativity === null) {
        logger.debug("Creativity selection cancelled or closed.");
        return void 0;
      } else if (selectedCreativity.key === "__DEFAULT__") {
        logger.debug("Default creativity selected in override.");
        return null;
      } else {
        logger.debug(`Override creativity selected: ${selectedCreativity.key}`);
        return selectedCreativity.key;
      }
    } catch (err) {
      logger.error("Error showing creativity selection modal:", err);
      new import_obsidian3.Notice("Could not show creativity selection.");
      return void 0;
    }
  }
  /** Calculates the position for the context menu */
  getMenuPosition(editorView, editor) {
    try {
      const fromPos = editor.getCursor("from");
      const toPos = editor.getCursor("to");
      const fromOffset = editor.posToOffset(fromPos);
      const toOffset = editor.posToOffset(toPos);
      const fromRect = editorView.coordsAtPos(fromOffset);
      const toRect = editorView.coordsAtPos(toOffset);
      if (!fromRect || !toRect)
        throw new Error("Could not get coords for cursor position");
      return { x: fromRect.left, y: toRect.bottom + (editorView.defaultLineHeight || 15) };
    } catch (e) {
      logger.error("Failed to get cursor coordinates for context menu:", e);
      return { x: window.innerWidth / 2, y: window.innerHeight / 2 };
    }
  }
  /** Executes the selected action with potential overrides */
  async runAction(action, editor, temporaryProviderId = void 0, temporaryTemperatureKey = void 0) {
    var _a, _b, _c, _d;
    const editorView = editor.cm;
    if (!editorView) {
      logger.error("CodeMirror view unavailable.");
      new import_obsidian3.Notice("Error initializing action.");
      return;
    }
    const spinner = editorView.plugin(spinnerPlugin);
    if (!spinner) {
      logger.error("SpinnerPlugin instance not found.");
      new import_obsidian3.Notice("Error initializing action display.");
      return;
    }
    const cursorPositionTo = editor.getCursor("to");
    const spinnerPosition = editor.posToOffset(cursorPositionTo);
    let hideSpinner = null;
    try {
      hideSpinner = spinner.show(spinnerPosition);
    } catch (e) {
      logger.error("Error showing spinner in runAction:", e);
      hideSpinner = null;
    }
    const selection = editor.getSelection();
    const selectedText = selection || editor.getValue();
    const cursorPositionFrom = editor.getCursor("from");
    const abortController = new AbortController();
    this.abortControllers.push(abortController);
    const imagesInBase64 = [];
    logger.info(`Running action: "${action.name}" (ID: ${action.id})`);
    const cleanup = (abortedByUser = false) => {
      if (hideSpinner) {
        try {
          hideSpinner();
        } catch (e) {
          logger.warn("Error hiding spinner:", e);
        }
        hideSpinner = null;
      }
      this.removeAbortController(abortController);
      if (abortedByUser) {
        new import_obsidian3.Notice("Action aborted.");
        logger.info(`Action "${action.name}" aborted by user.`);
      }
    };
    abortController.signal.addEventListener("abort", () => {
      cleanup(true);
    }, { once: true });
    try {
      const aiRequestWaiter = await (0, import_sdk2.waitForAI)();
      const aiProviders = await aiRequestWaiter.promise;
      const availableProviderIds = (_b = (_a = aiProviders.providers) == null ? void 0 : _a.map((p) => p.id)) != null ? _b : [];
      logger.debug("Available Provider IDs:", availableProviderIds);
      let providerIdToUse = null;
      const hasImages = imagesInBase64.length > 0;
      const globalMainProvider = this.settings.aiProviders.main;
      const globalVisionProvider = this.settings.aiProviders.vision;
      const actionProviderOverride = action.providerId;
      logger.debug("Determining Provider - Inputs:", { temporaryProviderId, actionProviderOverride, globalMainProvider, globalVisionProvider, hasImages });
      if (temporaryProviderId !== void 0) {
        providerIdToUse = temporaryProviderId;
        logger.debug(`Provider decision step 1: Using modal result: ${providerIdToUse === null ? "'Default' selected" : providerIdToUse}`);
      } else if (actionProviderOverride !== null) {
        providerIdToUse = actionProviderOverride;
        logger.debug(`Provider decision step 1: Using action setting override: ${providerIdToUse}`);
      } else {
        providerIdToUse = null;
        logger.debug(`Provider decision step 1: No override, intending global default.`);
      }
      if (providerIdToUse === null) {
        logger.debug("Provider decision step 2 (Resolving Default): Checking context...");
        if (hasImages && globalVisionProvider) {
          providerIdToUse = globalVisionProvider;
          logger.debug(`Provider decision step 2: Resolved to global Vision provider (images): ${providerIdToUse}`);
        } else {
          providerIdToUse = globalMainProvider;
          logger.debug(`Provider decision step 2: Resolved to global Main provider: ${providerIdToUse}`);
        }
      }
      if (!providerIdToUse) {
        logger.error("Provider determination failed: No Provider ID could be determined after fallbacks. Global Main Provider is likely unselected in settings.");
        new import_obsidian3.Notice("No AI provider selected. Please choose a 'Default Main Provider' in Local GPT settings.", 7e3);
        throw new Error("No AI provider selected. Check settings.");
      }
      const provider = aiProviders.providers.find((p) => p.id === providerIdToUse);
      if (!provider) {
        logger.error(`Provider validation failed: Resolved Provider ID "${providerIdToUse}" not found among available providers from SDK.`, { availableProviderIds });
        new import_obsidian3.Notice(`Error: Configured AI provider (ID: "${providerIdToUse}") not found or unavailable. Check AI Provider plugin settings or Local GPT settings.`, 7e3);
        throw new Error(`Configured AI provider (ID: "${providerIdToUse}") not found or unavailable.`);
      }
      logger.info(`Using provider: ${provider.name} (ID: ${provider.id}, Model: ${provider.model || "N/A"})`);
      const context = "";
      let finalTemperature;
      let temperatureSource = "Unknown";
      const globalCreativityKey = this.settings.defaults.creativity || "balanced";
      const globalDefaultTemperature = (_d = (_c = CREATIVITY[globalCreativityKey]) == null ? void 0 : _c.temperature) != null ? _d : 1;
      if (temporaryTemperatureKey !== void 0) {
        if (temporaryTemperatureKey === null) {
          finalTemperature = globalDefaultTemperature;
          temperatureSource = `Global Default (via modal override: ${globalCreativityKey})`;
        } else if (CREATIVITY[temporaryTemperatureKey]) {
          finalTemperature = CREATIVITY[temporaryTemperatureKey].temperature;
          temperatureSource = `Modal Override (${temporaryTemperatureKey})`;
        } else {
          finalTemperature = globalDefaultTemperature;
          temperatureSource = `Global Default (invalid modal key "${temporaryTemperatureKey}")`;
          logger.warn(`Invalid temporary creativity key "${temporaryTemperatureKey}", using global default.`);
        }
      } else if (action.temperature !== null && CREATIVITY[action.temperature]) {
        finalTemperature = CREATIVITY[action.temperature].temperature;
        temperatureSource = `Action Setting (${action.temperature})`;
      } else {
        finalTemperature = globalDefaultTemperature;
        temperatureSource = `Global Default (${globalCreativityKey})`;
      }
      logger.info(`Using final temperature: ${finalTemperature == null ? void 0 : finalTemperature.toFixed(1)} (Source: ${temperatureSource})`);
      const promptText = preparePrompt(action.prompt, selectedText, context);
      const systemPromptText = action.system || void 0;
      const executeOptions = {
        provider,
        prompt: promptText,
        systemPrompt: systemPromptText,
        images: imagesInBase64,
        options: {
          temperature: finalTemperature
        }
      };
      logger.debug("Executing AI request with options:", { ...executeOptions, prompt: promptText.substring(0, 100) + "...", images: imagesInBase64.length });
      const chunkHandler = await aiProviders.execute(executeOptions);
      let accumulatedText = "";
      let isThinking = false;
      const onUpdate = (currentFullText) => {
        if (!spinner || abortController.signal.aborted)
          return;
        try {
          let isCurrentlyThinking = false;
          const lastThinkOpen = currentFullText.lastIndexOf("<think>");
          if (lastThinkOpen !== -1) {
            const lastThinkClose = currentFullText.lastIndexOf("</think>");
            if (lastThinkClose === -1 || lastThinkOpen > lastThinkClose) {
              isCurrentlyThinking = true;
            }
          }
          if (isCurrentlyThinking !== isThinking) {
            logger.debug(`Changing thinking state visual: ${isCurrentlyThinking}`);
            spinner.showThinking(isCurrentlyThinking, spinnerPosition);
            isThinking = isCurrentlyThinking;
          }
          const displayText = currentFullText.replace(/<think>[\s\S]*?<\/think>\s*/g, "").replace(/<think>[\s\S]*$/, "");
          if (displayText.trim()) {
            spinner.updateContent(displayText, spinnerPosition);
          }
        } catch (e) {
          logger.error("Error during spinner update:", e);
        }
      };
      chunkHandler.onData((chunk, currentFullText) => {
        if (abortController.signal.aborted) {
          chunkHandler.abort();
          return;
        }
        accumulatedText = currentFullText;
        onUpdate(accumulatedText);
      });
      chunkHandler.onEnd(() => {
        if (abortController.signal.aborted) {
          logger.warn("Stream ended, but action was aborted before output insertion.");
          return;
        }
        logger.info(`Action "${action.name}" stream finished.`);
        cleanup();
        let thinkingContent = "";
        const thinkMatch = accumulatedText.match(/^\s*<think>([\s\S]*?)<\/think>\s*/);
        if (thinkMatch == null ? void 0 : thinkMatch[1]) {
          thinkingContent = thinkMatch[1].trim();
          logger.debug("Extracted thinking content:", thinkingContent.substring(0, 100) + "...");
        }
        const mainOutputText = removeThinkingTags(accumulatedText).trim();
        let finalOutput = "";
        if (thinkingContent) {
          finalOutput += `\`\`\`thoughts
${thinkingContent}
\`\`\`

`;
        }
        finalOutput += mainOutputText;
        if (!finalOutput.trim()) {
          logger.warn("Final output is empty, nothing to insert/replace.");
          return;
        }
        try {
          if (action.replace) {
            logger.debug(`Replacing selection (${cursorPositionFrom.line},${cursorPositionFrom.ch} to ${cursorPositionTo.line},${cursorPositionTo.ch})`);
            editor.replaceRange(finalOutput, cursorPositionFrom, cursorPositionTo);
          } else {
            logger.debug(`Inserting output below line ${cursorPositionTo.line}`);
            const insertPos = { line: cursorPositionTo.line + 1, ch: 0 };
            const textToInsert = `
${finalOutput.trim()}
`;
            editor.replaceRange(textToInsert, insertPos);
          }
        } catch (insertError) {
          logger.error("Error replacing/inserting final text:", insertError);
          new import_obsidian3.Notice("Error inserting AI response.");
        }
      });
      chunkHandler.onError((error) => {
        if (abortController.signal.aborted || error instanceof Error && error.name === "AbortError") {
          logger.warn(`Stream generation aborted (onError): ${error.message}`);
        } else {
          logger.error(`Error during AI stream generation:`, error);
          new import_obsidian3.Notice(`AI Provider Error: ${error.message}`, 7e3);
          cleanup();
        }
      });
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      if (!errorMessage.startsWith("No AI provider selected") && !errorMessage.startsWith("Configured AI provider")) {
        logger.error(`Setup Error before executing action "${action.name}":`, error);
        new import_obsidian3.Notice(`Error starting action: ${errorMessage}`, 7e3);
      }
      if (!abortController.signal.aborted) {
        cleanup();
      }
    }
  }
  // --- Lifecycle and Settings ---
  // (onunload, removeAbortController, Type Guards, loadSettings, escapeHandler, saveSettings remain unchanged from previous version)
  onunload() {
    logger.info("Unloading Local GPT Plugin...");
    this.abortControllers.forEach((controller) => {
      try {
        controller.abort();
      } catch (e) {
      }
    });
    this.abortControllers = [];
    document.removeEventListener("keydown", this.escapeHandler);
    logger.info("Local GPT Plugin Unloaded.");
  }
  /** Removes a specific AbortController from the active list */
  removeAbortController(controllerToRemove) {
    this.abortControllers = this.abortControllers.filter((c) => c !== controllerToRemove);
  }
  // --- User Defined Type Guards ---
  hasStringProperty(obj, prop) {
    return typeof obj === "object" && obj !== null && prop in obj && typeof obj[prop] === "string";
  }
  hasNumberProperty(obj, prop) {
    return typeof obj === "object" && obj !== null && prop in obj && typeof obj[prop] === "number";
  }
  isValidActionGroup(obj) {
    return typeof obj === "object" && obj !== null && this.hasStringProperty(obj, "id") && this.hasStringProperty(obj, "name") && "actions" in obj && Array.isArray(obj.actions);
  }
  isValidAction(obj) {
    return typeof obj === "object" && obj !== null && this.hasStringProperty(obj, "id") && this.hasStringProperty(obj, "name") && this.hasStringProperty(obj, "groupId") && this.hasStringProperty(obj, "prompt") && this.hasStringProperty(obj, "system") && typeof obj.replace === "boolean";
  }
  /** Loads plugin settings and performs migration if necessary */
  async loadSettings() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
    logger.debug("Loading settings...");
    try {
      const loadedData = await this.loadData();
      let migrationNeeded = false;
      const currentVersion = this.hasNumberProperty(loadedData, "_version") ? loadedData._version : 0;
      logger.info(`Loaded settings data version: ${currentVersion}`);
      if (currentVersion < 7) {
        logger.warn(`Settings version ${currentVersion} is too old (< 7). Resetting to defaults.`);
        this.settings = JSON.parse(JSON.stringify(DEFAULT_SETTINGS));
        migrationNeeded = true;
      } else if (currentVersion === 7) {
        logger.info("Migrating settings from v7 to v8...");
        const oldSettings = loadedData;
        const newSettings = JSON.parse(JSON.stringify(DEFAULT_SETTINGS));
        if (oldSettings.aiProviders) {
          newSettings.aiProviders.main = (_a = oldSettings.aiProviders.main) != null ? _a : null;
          newSettings.aiProviders.embedding = (_b = oldSettings.aiProviders.embedding) != null ? _b : null;
          newSettings.aiProviders.vision = (_c = oldSettings.aiProviders.vision) != null ? _c : null;
          logger.debug("Migrated provider IDs:", newSettings.aiProviders);
        }
        if (((_d = oldSettings.defaults) == null ? void 0 : _d.creativity) && CREATIVITY[oldSettings.defaults.creativity]) {
          newSettings.defaults.creativity = oldSettings.defaults.creativity;
          logger.debug("Migrated default creativity:", newSettings.defaults.creativity);
        }
        if (Array.isArray(oldSettings.actions) && oldSettings.actions.length > 0) {
          logger.debug(`Found ${oldSettings.actions.length} actions in v7 settings.`);
          const defaultGroupId2 = (_f = (_e = newSettings.actionGroups[0]) == null ? void 0 : _e.id) != null ? _f : v4_default();
          if (!newSettings.actionGroups[0]) {
            newSettings.actionGroups.push({ id: defaultGroupId2, name: "General (Migrated)", actions: [] });
            logger.debug("Created new default group for migration.");
          } else {
            newSettings.actionGroups[0].name = "General (Migrated)";
            logger.debug(`Using existing default group (ID: ${defaultGroupId2}), renamed.`);
          }
          newSettings.actionGroups[0].actions = oldSettings.actions.filter(
            (oldAction) => oldAction && typeof oldAction.name === "string" && oldAction.name.trim() !== ""
          ).map((oldAction) => {
            var _a2;
            return {
              id: v4_default(),
              groupId: defaultGroupId2,
              name: oldAction.name,
              prompt: oldAction.prompt || "",
              system: oldAction.system || "",
              replace: (_a2 = oldAction.replace) != null ? _a2 : false,
              providerId: null,
              temperature: null
            };
          });
          logger.info(`Migrated ${newSettings.actionGroups[0].actions.length} valid actions to group "${newSettings.actionGroups[0].name}".`);
        } else {
          logger.debug("No actions found in v7 settings to migrate.");
        }
        newSettings._version = 8;
        this.settings = newSettings;
        migrationNeeded = true;
      } else {
        logger.debug(`Loading settings version ${currentVersion}. Applying defaults for missing properties.`);
        const tempSettings = JSON.parse(JSON.stringify(DEFAULT_SETTINGS));
        const loadedObject = typeof loadedData === "object" && loadedData !== null ? loadedData : {};
        for (const key in loadedObject) {
          if (Object.prototype.hasOwnProperty.call(loadedObject, key)) {
            const loadedValue = loadedObject[key];
            if (loadedValue !== void 0 && key !== "aiProviders" && key !== "defaults" && key !== "actionGroups") {
              tempSettings[key] = loadedValue;
            }
          }
        }
        const loadedProviders = loadedObject.aiProviders;
        if (typeof loadedProviders === "object" && loadedProviders !== null) {
          tempSettings.aiProviders = { ...tempSettings.aiProviders, ...loadedProviders };
        }
        const loadedDefaults = loadedObject.defaults;
        if (typeof loadedDefaults === "object" && loadedDefaults !== null) {
          tempSettings.defaults = { ...tempSettings.defaults, ...loadedDefaults };
        }
        const loadedActionGroups = loadedObject.actionGroups;
        if (Array.isArray(loadedActionGroups)) {
          logger.debug("Loaded 'actionGroups' is an array. Validating and merging...");
          const validatedGroups = loadedActionGroups.filter(this.isValidActionGroup).map((g) => {
            logger.debug(`Validating group: ${g.name} (ID: ${g.id})`);
            const validatedActions = Array.isArray(g.actions) ? g.actions.filter(this.isValidAction) : [];
            if (Array.isArray(g.actions) && validatedActions.length !== g.actions.length) {
              logger.warn(`Group "${g.name}": Filtered out ${g.actions.length - validatedActions.length} invalid actions.`);
            }
            return { ...g, actions: validatedActions };
          });
          if (validatedGroups.length > 0) {
            tempSettings.actionGroups = validatedGroups;
            logger.debug(`Successfully merged ${validatedGroups.length} valid action groups.`);
            if (validatedGroups.length !== loadedActionGroups.length) {
              logger.warn(`Filtered out ${loadedActionGroups.length - validatedGroups.length} invalid groups during merge.`);
            }
          } else {
            logger.warn("Loaded 'actionGroups' array contained no valid groups. Using default group structure.");
            migrationNeeded = true;
          }
        } else if (loadedActionGroups !== void 0) {
          logger.warn("Loaded 'actionGroups' is not an array. Using default group structure.");
          migrationNeeded = true;
        }
        tempSettings._version = DEFAULT_SETTINGS._version;
        this.settings = tempSettings;
      }
      if (!this.settings.actionGroups || this.settings.actionGroups.length === 0) {
        logger.warn("CRITICAL: No valid action groups found after load/migration. Resetting to single default group.");
        const defaultGroup = JSON.parse(JSON.stringify(DEFAULT_SETTINGS.actionGroups[0]));
        defaultGroup.id = v4_default();
        defaultGroup.actions.forEach((a) => {
          a.id = v4_default();
          a.groupId = defaultGroup.id;
        });
        this.settings.actionGroups = [defaultGroup];
        migrationNeeded = true;
      } else {
        this.settings.actionGroups.forEach((g) => {
          var _a2, _b2;
          logger.debug(`Loaded Group: "${g.name}" (ID: ${g.id}), Actions: ${(_b2 = (_a2 = g.actions) == null ? void 0 : _a2.length) != null ? _b2 : 0}`);
        });
      }
      if (!this.settings.currentGroupId || !this.settings.actionGroups.some((g) => g.id === this.settings.currentGroupId)) {
        logger.warn(`Current group ID "${this.settings.currentGroupId}" is invalid or group not found. Resetting to first available group.`);
        this.settings.currentGroupId = (_h = (_g = this.settings.actionGroups[0]) == null ? void 0 : _g.id) != null ? _h : null;
        migrationNeeded = true;
      }
      if (!this.settings.defaults.creativity || !CREATIVITY[this.settings.defaults.creativity]) {
        logger.warn(`Invalid default creativity "${this.settings.defaults.creativity}". Resetting to "${DEFAULT_SETTINGS.defaults.creativity}".`);
        this.settings.defaults.creativity = DEFAULT_SETTINGS.defaults.creativity;
        migrationNeeded = true;
      }
      this.settings.showProviderInContextMenu = (_i = this.settings.showProviderInContextMenu) != null ? _i : false;
      this.settings.showCreativityInContextMenu = (_j = this.settings.showCreativityInContextMenu) != null ? _j : false;
      if (migrationNeeded) {
        logger.info("Saving migrated/corrected settings.");
        await this.saveSettings();
      }
      logger.debug("Settings loaded successfully.", JSON.parse(JSON.stringify(this.settings)));
    } catch (error) {
      logger.error("CRITICAL FAILURE during settings load/migration:", error);
      this.settings = JSON.parse(JSON.stringify(DEFAULT_SETTINGS));
      logger.warn("Using default settings due to CRITICAL loading/migration error.");
      try {
        await this.saveSettings();
      } catch (saveError) {
        logger.error("Failed to save default settings after load error:", saveError);
      }
    }
  }
  /** Saves the current plugin settings */
  async saveSettings() {
    logger.debug("Saving settings...");
    await this.saveData(this.settings);
    this.reload();
    logger.debug("Settings saved.");
  }
};
